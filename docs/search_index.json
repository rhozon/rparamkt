[
["index.html", "R para Estudantes de Marketing Sobre o autor desta tradução", " R para Estudantes de Marketing KU Leuven Marketing department (tradução: Rodrigo Hermont Ozon) 2020-09-16 Sobre o autor desta tradução Rodrigo Hermont Ozon, economista e apaixonado por econometria, pelas aplicações de modelos econômicos a problemas reais e cotidianos vivenciados na sociedade e na realidade do mundo empresarial e corporativo. Seus contatos podem ser acessados em: WebSite LinkeDin Resumo O objetivo de traduzir esse tutorial consiste em facilitar o aprendizado e utilização da linguagem estatística R para os profissionais de marketing e demais áreas de negócio que precisam se adequar a uma realidade mutante e movida por um fluxo significativo de informações por todos os lados. Trabalhar e interpretar bem os dados é um desafio computacional para muitos profissionais dessa área; e esta tradução visa cobrir (ainda que superficialmente) tal lacuna. Este bookdown foi escrito no inicialmente no overleaf com o pacote knitr para a página interativa de autoria de KU Leven Marketing Department. Ao meu amado paizão e professor pra vida inteira, Ronaldo – “Ensina a criança no caminho em que deve andar, e, ainda quando for velho, não se desviará dele.” Provérbios 22:6 Nota do tradutor Esse e-book traduzido é oriundo de R for marketing students. As traduções aqui são somente as transcrições. Não me preocupei em aperfeiçoá-las para a língua portuguesa com maior nível de clareza nos textos. As figuras e imagens não foram traduzidas. "],
["sobre-este-tutorial.html", "Sobre este tutorial Download e instalação do R e do RStudio Obtendo familiaridade com o Studio Comentários Pacotes", " Sobre este tutorial Neste tutorial, exploraremos o R como uma ferramenta para analisar e visualizar dados. O R é uma linguagem de programação estatística que rapidamente ganhou popularidade em muitos campos científicos. A principal diferença entre o R e outro software estatístico como o SPSS é que o R não possui interface gráfica com o usuário. Não há botões para clicar. O R é executado inteiramente digitando comandos em uma interface de texto. Isso pode parecer assustador, mas, esperançosamente, no final deste tutorial, você verá como o R pode ajudá-lo a fazer uma melhor análise estatística. Então, por que estamos usando R e não um dos muitos outros pacotes estatísticos como SPSS, SAS ou Microsoft Excel? Algumas das razões mais importantes: Ao contrário de outros softwares, o R é gratuito e de código aberto, e sempre será! R é uma linguagem de programação e não uma interface gráfica como o SPSS. Ele realiza análises ou visualizações executando algumas linhas de código. Essas linhas de código podem ser salvas como scripts para repetição futura das análises ou visualizações. Também facilita o compartilhamento de seu trabalho com outras pessoas, que podem aprender ou corrigi-lo se houver algum erro. O R tem uma comunidade online muito ativa e útil. Quando você se depara com um problema, muitas vezes basta uma rápida pesquisa no Google para encontrar uma solução de origem coletiva. Todas as principais empresas de pesquisa de marketing indicam que estão experimentando o R e que o R é o software do futuro. Este tutorial se concentra em análises estatísticas relevantes para estudantes de marketing. Se você quiser uma introdução mais extensa, porém acessível, ao R, confira o excelente e gratuito livro “R for Data Science”. Este capítulo introdutório e o próximo são baseados na introdução ao R, encontrada nos tutoriais do Coding Club, que também possui muitos outros ótimos tutoriais de R. Este tutorial foi escrito no RMarkdown, com a ajuda do incrível pacote bookdown. Questões? Comentários? Sugestões? Envie-me um e-mail: samuel.franssens@kuleuven.be Download e instalação do R e do RStudio Para fornecer algumas funcionalidades extras e facilitar um pouco a transição, usaremos um programa chamado R Studio como um front-end gráfico para o R. Você pode fazer o download do R em https://cloud.r-project.org/. Selecione o link apropriado para o seu sistema operacional e instale o R no seu computador (no Windows, você primeiro precisa clicar em “base”). Em seguida, faça o download do R Studio em https://www.rstudio.com/products/rstudio/download/. Selecione o instalador para a versão gratuita e instale o R Studio (nota: você precisa ter o R instalado primeiro). Obtendo familiaridade com o Studio Console vs. script Ao abrir o R Studio, você verá uma janela como a acima. Você pode digitar o código diretamente no console (janela inferior esquerda) - basta digitar seu código após o prompt (\\(&gt;\\)) e pressionar enter no final da linha para executar o código. Você também pode escrever seu código no arquivo de script (a janela superior esquerda). Se você não ver uma janela com um arquivo de script, abra uma clicando em Arquivo, Novo arquivo, R Script. Para executar uma linha de código a partir do seu script, pressione Ctrl + R ou Ctrl + Enter no Windows e Cmd + Enter no Mac ou use o botão ‘Executar’ no canto superior direito da janela do script. O código digitado diretamente no console não será salvo pelo R. O código digitado em um arquivo de script pode ser salvo como um registro reproduzível de sua análise. Se você estiver trabalhando no console e quiser editar ou executar novamente uma linha de código anterior, pressione a seta para cima. Se você estiver trabalhando em um script, lembre-se de clicar em Salvar frequentemente (Arquivo, Salvar), para que você realmente salve o seu script! É melhor trabalhar em arquivos de script. Também é altamente recomendável salvar seu arquivo de script em uma pasta que é automaticamente copiada pelo software de compartilhamento de arquivos que oferece a funcionalidade “versões anteriores” (o Dropbox é provavelmente o mais famoso; aqui estão algumas alternativas. Isso lhe dará a opção de restaurar versões salvas anteriormente de seus arquivos sempre que você salvar algo por engano. Como qualquer peça escrita, os roteiros se beneficiam de estrutura e clareza - a Coding Etiquette do Coding Club oferece mais conselhos sobre isso. Comentários Ao escrever um script, é muito importante adicionar comentários para descrever o que você está fazendo e por quê. Você pode fazer isso inserindo um # na frente de uma linha de texto. Comece seu script gravando quem está escrevendo o roteiro, a data e o objetivo principal - no capítulo introdutório, aprenderemos sobre as acomodações do Airbnb na Bélgica. Aqui está um exemplo: # Aprendendo a importar e explorar dados e criar graficos investigando as acomodacoes do Airbnb na Belgica # Escrito por Samuel Franssens 28/01/2018 Pacotes As próximas linhas de código geralmente carregam os pacotes que você usará em sua análise ou visualização. O R carrega automaticamente várias funções para executar operações básicas, mas os pacotes fornecem funcionalidade extra. Eles geralmente consistem em várias funções que podem lidar com tarefas específicas. Por exemplo, um pacote poderia fornecer funções para fazer análises de cluster ou para fazer biplots. Para instalar um pacote, digite install.packages (“nome do pacote”) (e pressione enter ao trabalhar no console ou pressione Ctrl + Enter, Ctrl + R, Cmd + Enter ou o botão ‘Executar’ ao trabalhar em um script). Você só precisa instalar pacotes uma vez; depois, basta carregá-los usando a biblioteca (nome do pacote). Aqui, usaremos o popular pacote tidyverse que fornece muitas funções úteis e intuitivas ( https://www.tidyverse.org/ ). O pacote tidyverse é na verdade uma coleção de outros pacotes; portanto, durante a instalação ou o carregamento, você verá que vários pacotes são instalados ou carregados. Instale e carregue o pacote tidyverse executando as seguintes linhas de código: #install.packages(tidyverse) # instala o pacote tidyverse library(tidyverse) # carrega o pacote tidyverse ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.3 v dplyr 1.0.0 ## v tidyr 1.1.2 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Observe que há aspas ao instalar um pacote, mas não ao carregá-lo. A instalação de um pacote normalmente produz muita saída no console. Você pode verificar se instalou um pacote com êxito, carregando o pacote. Se você tentar carregar um pacote que não foi instalado com sucesso, você receberá o seguinte erro: #library(marketing) # Estou tentando instalar o pacote inexistente &#39;marketing&#39; ## Error in library(marketing): there is no package called &#39;marketing&#39; Nesse caso, tente reinstalar o pacote. Quando você tenta usar uma função de um determinado pacote que ainda não foi carregado, você pode receber o seguinte erro: # agnes eh uma funcao do pacote cluster para rodar analise de cluster. #agnes(dist(data), metric = &quot;euclidean&quot;, method = &quot;ward&quot;) ## Error in agnes(dist(data), metric = &quot;euclidean&quot;, method = &quot;ward&quot;): could not find function &quot;agnes&quot; O R nos dirá que não pode encontrar a função solicitada (neste caso, agnes, uma função do pacote de cluster para análises de cluster). Geralmente, isso ocorre porque você ainda não carregou (ou instalou) o pacote ao qual a função pertence. Após instalar e carregar o pacote tidyverse, você poderá usar as funções incluídas no pacote tidyverse. Como você usará o pacote tidyverse com tanta frequência, é melhor sempre carregá-lo no início do seu script. "],
["introdução-ao-r.html", "Introdução ao R Importando dados Importando arquivos .csv Ajustando seu diretório de trabalho Atribuindo dados a objetos Importando arquivos do Excel Lendo os dados do Airbnb Manipulando dataframes O operador pipe Agrupando e resumindo", " Introdução ao R Neste capítulo introdutório, você aprenderá: como importar dados como manipular um conjunto de dados com o operador de canal como resumir um conjunto de dados como fazer gráficos de dispersão e histogramas Importando dados Neste capítulo, exploraremos um conjunto de dados publicamente disponível dos dados do Airbnb. Encontramos esses dados aqui. (Estes são dados reais “raspados” do airbnb.com em julho de 2017. Isso significa que o proprietário do site criou um script para coletar automaticamente esses dados no site airbnb.com. Essa é uma das muitas coisas que você também pode fazer no R. Mas primeiro vamos aprender o básico.) Você pode baixar o conjunto de dados clicando com o botão direito do mouse neste link, selecionando “Salvar link como…” (ou algo semelhante) e salvando o arquivo .csv em um diretório no disco rígido. Como mencionado na introdução, é uma boa ideia salvar seu trabalho em um diretório que é automaticamente copiado pelo software de compartilhamento de arquivos. Mais tarde, salvaremos nosso script no mesmo diretório. Importando arquivos .csv Para importar dados para o R, clique em Import Dataset e depois em From text (readr). Uma nova janela será exibida. Clique em Procurar e encontre seu arquivo de dados. Certifique-se de que Primeira linha como nomes esteja selecionada (isso diz ao R para tratar a primeira linha dos seus dados como os títulos das colunas) e clique em Importar. Após clicar em importar, o R Studio abre uma guia Visualizador. Isso mostra seus dados em uma planilha. Alguns computadores salvam arquivos .csv com ponto e vírgula (;) em vez de vírgulas (,) como separadores ou “delimitadores”. Isso geralmente acontece quando o inglês não é o primeiro ou o único idioma do seu computador. Se seus arquivos estiverem separados por ponto e vírgula, clique em Importar conjunto de dados e encontre seu arquivo de dados, mas agora escolha Ponto e vírgula no delimitador do menu suspenso. Nota: se você não salvou o conjunto de dados clicando com o botão direito do mouse no link e selecionando “Salvar link como…”, mas clicou com o botão esquerdo do mouse no link, seu navegador pode ter acabado abrindo o conjunto de dados. Você pode salvar o conjunto de dados pressionando Ctrl + S. Observe, no entanto, que seu navegador pode acabar salvando o conjunto de dados como um arquivo .txt. É importante alterar a extensão do seu arquivo nos argumentos para o comando read_csv abaixo. Ajustando seu diretório de trabalho Depois de importar seus dados com Import Dataset, verifique a janela do console. Você verá o comando para abrir o Visualizador (View()) e, uma linha acima, verá o comando que lê os dados. Copie o comando que lê os dados do console para o seu script. No meu caso, fica assim: #tomslee_airbnb_belgium_1454_2017_07_14 &lt;- read.csv(&quot;c:/Dropbox/work/teaching/R/data/tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) # Mude .csv para .txt se necessario airbnb&lt;-read.csv(file=&quot;http://users.telenet.be/samuelfranssens/tutorial_data/tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;, sep=&quot;,&quot;, head=TRUE) Esta linha tem a seguinte leitura (da direita para a esquerda): a funcao read_csv deve ler o arquivo tomslee_airbnb_belgium_1454_2017-07-14.csv no diretorio c: / Dropbox / work / teaching / R / data / (voce vera um diretorio diferente aqui ) Em seguida, R deve atribuir (\\(&lt;-\\)) esses dados a um objeto chamado tomslee_airbnb_belgium_1454_2017_07_14. Antes de explicar cada um desses conceitos, vamos simplificar esta linha de código: #setwd(&quot;c:/Dropbox/work/teaching/R/data/&quot;) # Ajusta o diretorio de trabalho para onde o R precisa apontar para o arquivo .csv #airbnb &lt;- read_csv(&quot;tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) # read_csv agora nao precisa mais de um diretorio e somente precisa de um nome de arquivo # Atribuimos os dados a um objeto com um nome mais simples: airbnb em vez de tomslee_airbnb_belgium_1454_2017_07_14 O comando setwd informa ao R onde está o seu diretório de trabalho. Seu diretório de trabalho é uma pasta no seu computador onde o R procurará dados, onde as plotagens serão salvas etc. Defina seu diretório de trabalho na pasta em que os dados foram armazenados. Agora, o arquivo read_csv não requer mais um diretório. Você só precisa definir seu diretório de trabalho uma vez, na parte superior do seu script. Você pode verificar se está definido corretamente executando getwd(). Observe que em um computador com Windows, os caminhos de arquivo possuem barras invertidas que separam as pastas (“C: folder data”). No entanto, o caminho do arquivo digitado no R deve usar barras (“C: / folder / data”). Salve este script no diretório de trabalho (no meu caso: c: / Dropbox / trabalho / ensino / R / dados /)). No futuro, você pode simplesmente executar essas linhas de código para importar seus dados em vez de clicar em Importar conjunto de dados (a execução de linhas de código é muito mais rápida do que apontar e clicar - uma das vantagens do uso do R). Não se esqueça de carregar o pacote tidyverse na parte superior do seu script (mesmo antes de definir o diretório de trabalho) com a biblioteca (tidyverse). Atribuindo dados a objetos Observe a seta \\(&lt;-\\) no meio da linha que importou o arquivo .csv: #airbnb &lt;- read_csv(&quot;tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) \\(&lt;-\\) é o operador de atribuição. Nesse caso, atribuímos o conjunto de dados (ou seja, os dados que lemos do arquivo .csv) a um objeto chamado airbnb. Um objeto é uma estrutura de dados. Todos os objetos que você criar serão exibidos no painel Ambiente (a janela superior direita). O R Studio fornece um atalho para escrever \\(&lt;-\\): Alt + - (no Windows). É uma boa ideia aprender esse atalho de cor. Quando você importa dados para o R, ele se torna um objeto chamado quadro de dados. Um quadro de dados é como uma tabela ou uma planilha do Excel. Tem duas dimensões: linhas e colunas. Geralmente, as linhas representam suas observações, as colunas representam as diferentes variáveis. Quando seus dados consistem em apenas uma dimensão (por exemplo, uma sequência de números ou palavras), eles são armazenados em um segundo tipo de objeto chamado vetor. Mais tarde, aprenderemos como criar vetores. Importando arquivos do Excel O R funciona melhor com arquivos .csv (valores separados por vírgula). No entanto, os dados geralmente são armazenados como um arquivo do Excel (você pode baixar o conjunto de dados do Airbnb como um arquivo do Excel aqui). O R também pode lidar com isso, mas você precisará carregar primeiro um pacote chamado readxl (este pacote faz parte do pacote tidyverse, mas não é carregado com a biblioteca (tidyverse) porque não é um pacote tidyverse principal): library(readxl) # carrega o pacote #airbnb.excel &lt;- read_excel (path = &quot;tomslee_airbnb_belgium_1454_2017-07-14.xlsx&quot;, sheet = &quot;Sheet1&quot;) # verifique se o arquivo do Excel está salvo no seu diretório de trabalho # você também pode deixar de fora o path = &amp; sheet = # então o comando se torna: read_excel (&quot;tomslee_airbnb_belgium_1454_2017-07-14.xlsx&quot;, &quot;Sheet1&quot;) read_excel é uma função do pacote readxl. São necessários dois argumentos: o primeiro é o nome do arquivo e o segundo é o nome da planilha do Excel que você deseja ler. Lendo os dados do Airbnb Nosso conjunto de dados contém informações sobre quartos na Bélgica listados no airbnb.com. Sabemos para cada sala (identificada por room_id): quem é o hóspede (host_id), que tipo de sala é (room_type), onde está localizada (country, city, neighborhood e até a latitude e longitude exata), como muitas críticas que recebeu (), como as pessoas estavam satisfeitas (overall_satisfaction), preço (price) e características dos quartos (accommodates, bedrooms, bathrooms, minstay). Uma etapa realmente importante é verificar se seus dados foram importados corretamente. É uma boa prática sempre inspecionar seus dados. Você vê algum valor ausente, os números e os nomes fazem sentido? Se você começar imediatamente com a análise, corre o risco de ter que refazê-la porque os dados não foram lidos corretamente, ou pior, analisando dados errados sem perceber. airbnb[1:10,] # Visualiza o conteudo do conjunto de dados da Airbnb para as dez primeiras linhas ## room_id survey_id host_id room_type country city borough neighborhood reviews ## 1 5141135 1454 20676997 Shared room NA Belgium Gent Gent 9 ## 2 13128333 1454 46098805 Shared room NA Belgium Brussel Schaarbeek 2 ## 3 8298885 1454 30924336 Shared room NA Belgium Brussel Elsene 12 ## 4 13822088 1454 81440431 Shared room NA Belgium Oostende Middelkerke 19 ## 5 18324301 1454 14294054 Shared room NA Belgium Brussel Anderlecht 5 ## 6 12664969 1454 68810179 Shared room NA Belgium Brussel Koekelberg 28 ## 7 15452889 1454 99127166 Shared room NA Belgium Gent Gent 2 ## 8 3911778 1454 3690027 Shared room NA Belgium Brussel Elsene 13 ## 9 14929414 1454 30624501 Shared room NA Belgium Verviers Baelen 2 ## 10 8497852 1454 40513093 Shared room NA Belgium Brussel Etterbeek 57 ## overall_satisfaction accommodates bedrooms bathrooms price minstay ## 1 4.5 2 1 NA 59 NA ## 2 0.0 2 1 NA 53 NA ## 3 4.0 2 1 NA 46 NA ## 4 4.5 4 1 NA 56 NA ## 5 5.0 2 1 NA 47 NA ## 6 5.0 4 1 NA 60 NA ## 7 0.0 2 1 NA 41 NA ## 8 4.0 2 1 NA 36 NA ## 9 0.0 8 1 NA 18 NA ## 10 4.5 3 1 NA 38 NA ## name last_modified latitude ## 1 Spacious shared apartment in Gent 2017-07-17 03:49:10.237453 51.03420 ## 2 appartement cosy 2017-07-17 03:49:09.020871 50.86915 ## 3 YOU&#39;LL FEEL AT HOME!!! 2017-07-17 03:49:09.014704 50.82829 ## 4 studio douillet pour un sÃ©jour &quot;Low-budget&quot; 2017-07-17 03:49:07.929876 51.19050 ## 5 NICE place..metro..tram. TGV..BUS................. 2017-07-17 03:49:07.918941 50.83971 ## 6 Chez Toi in Bruxelles 2017-07-17 03:49:06.301487 50.85910 ## 7 a day in the life of a beautifull home 2017-07-17 03:49:04.064557 51.05508 ## 8 Calm Bruxellois area 2017-07-17 03:49:02.489395 50.81425 ## 9 Ecurie du Bois DorÃ©, dortoir agrÃ©able 2017-07-17 03:49:02.477617 50.63320 ## 10 Bel appartement cosy Ã partager 2017-07-17 03:49:01.173568 50.83771 ## longitude location ## 1 3.714149 0101000020E6100000D2C43BC093B60D40874F3A9160844940 ## 2 4.384435 0101000020E610000044C02154A9891140321CCF67406F4940 ## 3 4.376590 0101000020E6100000A80018CFA0811140BC404981056A4940 ## 4 2.822373 0101000020E610000042E8A04B38940640AAF1D24D62984940 ## 5 4.333850 0101000020E610000012143FC6DC551140F67AF7C77B6B4940 ## 6 4.336969 0101000020E61000003410CB660E591140BD8BF7E3F66D4940 ## 7 3.746806 0101000020E610000011A7936C75F90D40B265F9BA0C874940 ## 8 4.384256 0101000020E6100000C72AA5677A8911400C73823639684940 ## 9 5.950236 0101000020E61000006CED7DAA0ACD174071766B990C514940 ## 10 4.394056 0101000020E6100000992B836A83931140EE3F321D3A6B4940 O R nos diz que estamos lidando com uma __tibble_ (essa é apenas outra palavra para quadro de dados) com 17651 linhas ou observações e 20 colunas ou variáveis. Para cada coluna, é fornecido o tipo da variável: int (inteiro), chr (caractere), dbl (duplo), dttm (data e hora). Variáveis inteiras e duplas armazenam números (inteiro para números redondos, duplicam para números com decimais), variáveis de caracteres armazenam letras, variáveis de data e hora armazenam datas e / ou horas. O R imprime apenas os dados das dez primeiras linhas e o número máximo de colunas que cabem na tela. Se, no entanto, você deseja inspecionar todo o conjunto de dados, clique duas vezes no objeto airbnb no painel Ambiente (a janela superior direita) para abrir uma aba Visualizador ou executar a Visualização (airbnb). Observe o V maiúsculo no comando Visualizar. O R sempre diferencia maiúsculas de minúsculas! Você também pode usar o comando print para solicitar mais (ou menos) linhas e colunas na janela do console: # Imprima 25 linhas (defina como Inf para imprimir todas as linhas) e defina a largura como 100 para ver mais colunas. # Observe que as colunas que nao cabem na primeira tela com 25 linhas # sao impressos abaixo das 25 linhas iniciais. #print (airbnb, n = 25, width = 100) airbnb[1:25,] ## room_id survey_id host_id room_type country city borough neighborhood ## 1 5141135 1454 20676997 Shared room NA Belgium Gent Gent ## 2 13128333 1454 46098805 Shared room NA Belgium Brussel Schaarbeek ## 3 8298885 1454 30924336 Shared room NA Belgium Brussel Elsene ## 4 13822088 1454 81440431 Shared room NA Belgium Oostende Middelkerke ## 5 18324301 1454 14294054 Shared room NA Belgium Brussel Anderlecht ## 6 12664969 1454 68810179 Shared room NA Belgium Brussel Koekelberg ## 7 15452889 1454 99127166 Shared room NA Belgium Gent Gent ## 8 3911778 1454 3690027 Shared room NA Belgium Brussel Elsene ## 9 14929414 1454 30624501 Shared room NA Belgium Verviers Baelen ## 10 8497852 1454 40513093 Shared room NA Belgium Brussel Etterbeek ## 11 19372053 1454 18715177 Shared room NA Belgium Tournai Brunehaut ## 12 19855549 1454 128685860 Shared room NA Belgium Brussel Etterbeek ## 13 6772358 1454 34993608 Shared room NA Belgium Gent Gent ## 14 13852832 1454 81817614 Shared room NA Belgium Arlon Arlon ## 15 11581251 1454 49968974 Shared room NA Belgium Kortrijk Waregem ## 16 3645177 1454 18411614 Shared room NA Belgium Antwerpen Boom ## 17 12032748 1454 63713892 Shared room NA Belgium Verviers BÃ¼llingen ## 18 12034268 1454 63713892 Shared room NA Belgium Verviers BÃ¼llingen ## 19 427739 1454 1328011 Shared room NA Belgium Gent Gent ## 20 14194882 1454 86071645 Shared room NA Belgium Brussel Sint-Jans-Molenbeek ## 21 19298546 1454 107330233 Shared room NA Belgium Leuven Rotselaar ## 22 12133666 1454 62134289 Shared room NA Belgium Brugge Jabbeke ## 23 4419833 1454 22943117 Shared room NA Belgium Ath Ath ## 24 15573750 1454 20497610 Shared room NA Belgium Leuven Leuven ## 25 1334575 1454 3508041 Shared room NA Belgium Tongeren Voeren ## reviews overall_satisfaction accommodates bedrooms bathrooms price minstay ## 1 9 4.5 2 1 NA 59 NA ## 2 2 0.0 2 1 NA 53 NA ## 3 12 4.0 2 1 NA 46 NA ## 4 19 4.5 4 1 NA 56 NA ## 5 5 5.0 2 1 NA 47 NA ## 6 28 5.0 4 1 NA 60 NA ## 7 2 0.0 2 1 NA 41 NA ## 8 13 4.0 2 1 NA 36 NA ## 9 2 0.0 8 1 NA 18 NA ## 10 57 4.5 3 1 NA 38 NA ## 11 1 0.0 4 1 NA 14 NA ## 12 0 0.0 2 1 NA 37 NA ## 13 143 5.0 2 1 NA 28 NA ## 14 0 0.0 1 1 NA 177 NA ## 15 1 0.0 4 1 NA 147 NA ## 16 3 4.5 2 1 NA 177 NA ## 17 0 0.0 2 1 NA 129 NA ## 18 0 0.0 2 1 NA 140 NA ## 19 9 5.0 2 1 NA 141 NA ## 20 0 0.0 5 1 NA 136 NA ## 21 1 0.0 2 1 NA 132 NA ## 22 0 0.0 1 1 NA 117 NA ## 23 0 0.0 6 1 NA 106 NA ## 24 3 5.0 1 1 NA 116 NA ## 25 13 4.5 2 1 NA 106 NA ## name last_modified latitude ## 1 Spacious shared apartment in Gent 2017-07-17 03:49:10.237453 51.03420 ## 2 appartement cosy 2017-07-17 03:49:09.020871 50.86915 ## 3 YOU&#39;LL FEEL AT HOME!!! 2017-07-17 03:49:09.014704 50.82829 ## 4 studio douillet pour un sÃ©jour &quot;Low-budget&quot; 2017-07-17 03:49:07.929876 51.19050 ## 5 NICE place..metro..tram. TGV..BUS................. 2017-07-17 03:49:07.918941 50.83971 ## 6 Chez Toi in Bruxelles 2017-07-17 03:49:06.301487 50.85910 ## 7 a day in the life of a beautifull home 2017-07-17 03:49:04.064557 51.05508 ## 8 Calm Bruxellois area 2017-07-17 03:49:02.489395 50.81425 ## 9 Ecurie du Bois DorÃ©, dortoir agrÃ©able 2017-07-17 03:49:02.477617 50.63320 ## 10 Bel appartement cosy Ã partager 2017-07-17 03:49:01.173568 50.83771 ## 11 Chambre 3/4 pers.dans ferme du vieux chateau 2017-07-17 03:49:01.170957 50.51770 ## 12 Cosy &amp; bright living room with comfy sleep options 2017-07-17 03:49:01.162682 50.82749 ## 13 Couch-bed in Ghent 2017-07-17 03:49:01.157750 51.03783 ## 14 Logement 2017-07-17 03:48:56.542112 49.68641 ## 15 Terrasappartement 62 2017-07-17 03:48:56.536289 50.87617 ## 16 PRIVATE ROOM near TOMORROWLAND 2017-07-17 03:48:56.533485 51.09316 ## 17 Spacious, two-person room 2017-07-17 03:48:55.128993 50.40610 ## 18 Spacious, two-person room 2017-07-17 03:48:55.126446 50.40801 ## 19 penthouse room + hammam + sauna 2017-07-17 03:48:55.118066 51.05114 ## 20 Appartement 2017-07-17 03:48:55.115298 50.86178 ## 21 House with garden, 15min walk from Rock Werchter 2017-07-17 03:48:55.107495 50.97806 ## 22 Oud gemeentehuis 2017-07-17 03:48:53.534073 51.18761 ## 23 Chambre d&#39;hÃ´tes familiale 2017-07-17 03:48:53.529122 50.62833 ## 24 The Cozy Duplex Shared Room in Leuven center 2017-07-17 03:48:53.526629 50.87826 ## 25 Voerstreek, B&amp;B in natural area, near river, 2p,br 2017-07-17 03:48:53.521226 50.75655 ## longitude location ## 1 3.714149 0101000020E6100000D2C43BC093B60D40874F3A9160844940 ## 2 4.384435 0101000020E610000044C02154A9891140321CCF67406F4940 ## 3 4.376590 0101000020E6100000A80018CFA0811140BC404981056A4940 ## 4 2.822373 0101000020E610000042E8A04B38940640AAF1D24D62984940 ## 5 4.333850 0101000020E610000012143FC6DC551140F67AF7C77B6B4940 ## 6 4.336969 0101000020E61000003410CB660E591140BD8BF7E3F66D4940 ## 7 3.746806 0101000020E610000011A7936C75F90D40B265F9BA0C874940 ## 8 4.384256 0101000020E6100000C72AA5677A8911400C73823639684940 ## 9 5.950236 0101000020E61000006CED7DAA0ACD174071766B990C514940 ## 10 4.394056 0101000020E6100000992B836A83931140EE3F321D3A6B4940 ## 11 3.384048 0101000020E6100000F0C000C287120B40E3FC4D2844424940 ## 12 4.384322 0101000020E61000008388D4B48B8911405E66D828EB694940 ## 13 3.714062 0101000020E6100000E4874A2366B60D4062670A9DD7844940 ## 14 5.830874 0101000020E6100000066344A2D05217407DCA3159DCD74840 ## 15 3.401739 0101000020E6100000D238D4EFC2360B40105A0F5F26704940 ## 16 4.380444 0101000020E610000073D6A71C938511405D328E91EC8B4940 ## 17 6.264116 0101000020E6100000BE66B96C740E19408B6B7C26FB334940 ## 18 6.262573 0101000020E61000001C40BFEFDF0C19407138F3AB39344940 ## 19 3.746296 0101000020E6100000BE1589096AF80D404D2D5BEB8B864940 ## 20 4.342785 0101000020E6100000C93CF207035F1140253D0CAD4E6E4940 ## 21 4.692590 0101000020E610000085251E5036C512408EB27E33317D4940 ## 22 3.144082 0101000020E6100000C689AF76142709408733BF9A03984940 ## 23 3.685758 0101000020E610000050C3B7B06E7C0D40FE9C82FC6C504940 ## 24 4.713825 0101000020E6100000D044D8F0F4DA1240172D40DB6A704940 ## 25 5.718163 0101000020E6100000FBC9181F66DF1640B6F5D37FD6604940 Manipulando dataframes Transformando variáveis Fatoração Vamos observar nosso dataset novamente: airbnb[1:20,1:8] ## room_id survey_id host_id room_type country city borough neighborhood ## 1 5141135 1454 20676997 Shared room NA Belgium Gent Gent ## 2 13128333 1454 46098805 Shared room NA Belgium Brussel Schaarbeek ## 3 8298885 1454 30924336 Shared room NA Belgium Brussel Elsene ## 4 13822088 1454 81440431 Shared room NA Belgium Oostende Middelkerke ## 5 18324301 1454 14294054 Shared room NA Belgium Brussel Anderlecht ## 6 12664969 1454 68810179 Shared room NA Belgium Brussel Koekelberg ## 7 15452889 1454 99127166 Shared room NA Belgium Gent Gent ## 8 3911778 1454 3690027 Shared room NA Belgium Brussel Elsene ## 9 14929414 1454 30624501 Shared room NA Belgium Verviers Baelen ## 10 8497852 1454 40513093 Shared room NA Belgium Brussel Etterbeek ## 11 19372053 1454 18715177 Shared room NA Belgium Tournai Brunehaut ## 12 19855549 1454 128685860 Shared room NA Belgium Brussel Etterbeek ## 13 6772358 1454 34993608 Shared room NA Belgium Gent Gent ## 14 13852832 1454 81817614 Shared room NA Belgium Arlon Arlon ## 15 11581251 1454 49968974 Shared room NA Belgium Kortrijk Waregem ## 16 3645177 1454 18411614 Shared room NA Belgium Antwerpen Boom ## 17 12032748 1454 63713892 Shared room NA Belgium Verviers BÃ¼llingen ## 18 12034268 1454 63713892 Shared room NA Belgium Verviers BÃ¼llingen ## 19 427739 1454 1328011 Shared room NA Belgium Gent Gent ## 20 14194882 1454 86071645 Shared room NA Belgium Brussel Sint-Jans-Molenbeek Vimos que room_id e host_id são “identificadores” ou rótulos que identificam as observações. São nomes (neste caso, apenas números) para as salas(quartos) e hóspedes específicos. No entanto, vemos que o R os trata como números inteiros, ou seja, como números. Isso significa que poderíamos adicionar os room_id‘s de duas salas diferentes e obter um novo número. No entanto, isso não faria muito sentido, porque os room_id são apenas rótulos. Certifique-se de que R trate os identificadores como rótulos, em vez de números, fatorando-os. Observe o operador $. Este operador muito importante nos permite selecionar variáveis específicas de um quadro de dados, neste caso room_id e host_id. airbnb$room_id_F &lt;- factor(airbnb$room_id) airbnb$host_id_F &lt;- factor(airbnb$host_id) Uma variável de fator é semelhante a uma variável de caractere, pois armazena letras. Os fatores são mais úteis para variáveis que podem assumir apenas um número de categorias pré-determinadas. Eles devem, por exemplo, ser usados para variáveis dependentes categóricas - por exemplo, se uma venda foi feita ou não: venda versus não venda. Você pode pensar em fatores como variáveis que armazenam rótulos. Os rótulos reais não são tão importantes (não nos importamos se uma venda é chamada de venda ou sucesso ou algo mais), apenas os usamos para fazer uma distinção entre categorias diferentes. É muito importante fatorar variáveis inteiras que representam variáveis independentes ou dependentes categóricas, porque, se não fatorarmos essas variáveis, elas serão tratadas como contínuas em vez de variáveis categóricas nas análises. Por exemplo, uma variável pode representar uma venda como 1 e uma não-venda como 0. Nesse caso, é importante informar ao R que essa variável deve ser tratada como uma variável categórica em vez de contínua. As variáveis de caractere são diferentes das variáveis de fator, pois não são apenas rótulos para categorias. Um exemplo de variável de caractere seria uma variável que armazena as respostas dos entrevistados para uma pergunta em aberto. Aqui, o conteúdo real é importante (nós nos importamos se alguém descreve sua estadia no Airbnb como muito boa ou excelente ou outra coisa). No conjunto de dados do airbnb, os room_id não são rigorosamente determinados de antemão, mas definitivamente são rótulos e não devem ser tratados como números. Por isso, pedimos para o R convertê-los em fatores. Vamos dar uma olhada no conjunto de dados do airbnb novamente para verificar se o tipo dessas variáveis mudou após fatorar: str(airbnb) ## &#39;data.frame&#39;: 17651 obs. of 22 variables: ## $ room_id : int 5141135 13128333 8298885 13822088 18324301 12664969 15452889 3911778 14929414 8497852 ... ## $ survey_id : int 1454 1454 1454 1454 1454 1454 1454 1454 1454 1454 ... ## $ host_id : int 20676997 46098805 30924336 81440431 14294054 68810179 99127166 3690027 30624501 40513093 ... ## $ room_type : chr &quot;Shared room&quot; &quot;Shared room&quot; &quot;Shared room&quot; &quot;Shared room&quot; ... ## $ country : logi NA NA NA NA NA NA ... ## $ city : chr &quot;Belgium&quot; &quot;Belgium&quot; &quot;Belgium&quot; &quot;Belgium&quot; ... ## $ borough : chr &quot;Gent&quot; &quot;Brussel&quot; &quot;Brussel&quot; &quot;Oostende&quot; ... ## $ neighborhood : chr &quot;Gent&quot; &quot;Schaarbeek&quot; &quot;Elsene&quot; &quot;Middelkerke&quot; ... ## $ reviews : int 9 2 12 19 5 28 2 13 2 57 ... ## $ overall_satisfaction: num 4.5 0 4 4.5 5 5 0 4 0 4.5 ... ## $ accommodates : int 2 2 2 4 2 4 2 2 8 3 ... ## $ bedrooms : num 1 1 1 1 1 1 1 1 1 1 ... ## $ bathrooms : logi NA NA NA NA NA NA ... ## $ price : num 59 53 46 56 47 60 41 36 18 38 ... ## $ minstay : logi NA NA NA NA NA NA ... ## $ name : chr &quot;Spacious shared apartment in Gent&quot; &quot;appartement cosy&quot; &quot;YOU&#39;LL FEEL AT HOME!!!&quot; &quot;studio douillet pour un sÃ©jour \\&quot;Low-budget\\&quot;&quot; ... ## $ last_modified : chr &quot;2017-07-17 03:49:10.237453&quot; &quot;2017-07-17 03:49:09.020871&quot; &quot;2017-07-17 03:49:09.014704&quot; &quot;2017-07-17 03:49:07.929876&quot; ... ## $ latitude : num 51 50.9 50.8 51.2 50.8 ... ## $ longitude : num 3.71 4.38 4.38 2.82 4.33 ... ## $ location : chr &quot;0101000020E6100000D2C43BC093B60D40874F3A9160844940&quot; &quot;0101000020E610000044C02154A9891140321CCF67406F4940&quot; &quot;0101000020E6100000A80018CFA0811140BC404981056A4940&quot; &quot;0101000020E610000042E8A04B38940640AAF1D24D62984940&quot; ... ## $ room_id_F : Factor w/ 17651 levels &quot;2352&quot;,&quot;2354&quot;,..: 3018 9403 5877 10201 15058 9008 11815 2187 11309 6053 ... ## $ host_id_F : Factor w/ 13258 levels &quot;2582&quot;,&quot;6253&quot;,..: 4409 8169 6071 10679 3314 9992 11493 848 6016 7488 ... Vemos que o tipo de room_id e host_id agora é fct (fator). Transformações numéricas Vamos dar uma olhada nas classificações das acomodações: # Uso a funcao head para garantir que o R mostre apenas as primeiras classificacoes. # Caso contrario, teremos uma lista muito longa de classificacoes.. head(airbnb$overall_satisfaction) ## [1] 4.5 0.0 4.0 4.5 5.0 5.0 Vemos que as classificações estão em uma escala de 0 a 5. Se preferirmos ter classificações em uma escala de 0 a 100, poderíamos simplesmente multiplicar as classificações por 20: airbnb$overall_satisfaction_100 &lt;- airbnb$overall_satisfaction * 20 # Perceba que criamos uma nova variavel overall_satisfaction_100. # A variavel original overall_satisfaction continua inalterada. # Você tambem pode inspecionar todo o conjunto de dados com o Visualizador # e veja se ha uma nova coluna a direita. head(airbnb$overall_satisfaction_100) ## [1] 90 0 80 90 100 100 Transformando variáveis com a função mutate Também podemos transformar variáveis com a função mutate: library(dplyr)#pacote da funcao mutate airbnb &lt;- mutate(airbnb, room_id_F = factor(room_id), host_id_F = factor(host_id), overall_satisfaction_100 = overall_satisfaction * 20) Isso instrui R a pegar o conjunto de dados do airbnb, criar uma nova variável room_id_F que deve ser a fatoração de room_id, uma nova variável host_id_F que deve ser a fatoração de host_id e uma nova variável overall_satisfaction_100 que deve ser a satisfação geral vezes 20. O conjunto de dados com esses mutações (transformações) devem ser atribuídas ao objeto airbnb. Observe que não precisamos usar o operador $ aqui, porque a função mutate sabe desde seu primeiro argumento (airbnb) onde procurar determinadas variáveis e, portanto, não precisamos especificá-lo posteriormente com airbnb $. Uma vantagem do uso da função mutate é que ela mantém bem todas as transformações desejadas dentro de um comando. Outra grande vantagem do uso do mutate será discutida na seção sobre o operador pipe. Incluindo ou excluindo e renomeando variáveis (colunas) Se olharmos para os dados, também podemos ver que country é NA, o que significa que não está disponível ou está ausente. city é sempre a Bélgica (o que está errado porque a Bélgica é um país, não uma cidade) e o borought contém as informações da cidade. Vamos corrigir esses erros removendo a variável country de nosso conjunto de dados e renomeando city e borought. Também excluiremos o survey_id porque essa variável é constante nas observações e não a usaremos no restante da análise: airbnb &lt;- select(airbnb, -country, -survey_id) # Diga R para remover country &amp; survey_id do quadro de dados do airbnb incluindo um sinal de menos antes dessas variáveis. # Atribua novamente esse novo quadro de dados ao objeto airbnb. str(airbnb) # Agora você verá que o country e o survey_id se foram. ## &#39;data.frame&#39;: 17651 obs. of 21 variables: ## $ room_id : int 5141135 13128333 8298885 13822088 18324301 12664969 15452889 3911778 14929414 8497852 ... ## $ host_id : int 20676997 46098805 30924336 81440431 14294054 68810179 99127166 3690027 30624501 40513093 ... ## $ room_type : chr &quot;Shared room&quot; &quot;Shared room&quot; &quot;Shared room&quot; &quot;Shared room&quot; ... ## $ city : chr &quot;Belgium&quot; &quot;Belgium&quot; &quot;Belgium&quot; &quot;Belgium&quot; ... ## $ borough : chr &quot;Gent&quot; &quot;Brussel&quot; &quot;Brussel&quot; &quot;Oostende&quot; ... ## $ neighborhood : chr &quot;Gent&quot; &quot;Schaarbeek&quot; &quot;Elsene&quot; &quot;Middelkerke&quot; ... ## $ reviews : int 9 2 12 19 5 28 2 13 2 57 ... ## $ overall_satisfaction : num 4.5 0 4 4.5 5 5 0 4 0 4.5 ... ## $ accommodates : int 2 2 2 4 2 4 2 2 8 3 ... ## $ bedrooms : num 1 1 1 1 1 1 1 1 1 1 ... ## $ bathrooms : logi NA NA NA NA NA NA ... ## $ price : num 59 53 46 56 47 60 41 36 18 38 ... ## $ minstay : logi NA NA NA NA NA NA ... ## $ name : chr &quot;Spacious shared apartment in Gent&quot; &quot;appartement cosy&quot; &quot;YOU&#39;LL FEEL AT HOME!!!&quot; &quot;studio douillet pour un sÃ©jour \\&quot;Low-budget\\&quot;&quot; ... ## $ last_modified : chr &quot;2017-07-17 03:49:10.237453&quot; &quot;2017-07-17 03:49:09.020871&quot; &quot;2017-07-17 03:49:09.014704&quot; &quot;2017-07-17 03:49:07.929876&quot; ... ## $ latitude : num 51 50.9 50.8 51.2 50.8 ... ## $ longitude : num 3.71 4.38 4.38 2.82 4.33 ... ## $ location : chr &quot;0101000020E6100000D2C43BC093B60D40874F3A9160844940&quot; &quot;0101000020E610000044C02154A9891140321CCF67406F4940&quot; &quot;0101000020E6100000A80018CFA0811140BC404981056A4940&quot; &quot;0101000020E610000042E8A04B38940640AAF1D24D62984940&quot; ... ## $ room_id_F : Factor w/ 17651 levels &quot;2352&quot;,&quot;2354&quot;,..: 3018 9403 5877 10201 15058 9008 11815 2187 11309 6053 ... ## $ host_id_F : Factor w/ 13258 levels &quot;2582&quot;,&quot;6253&quot;,..: 4409 8169 6071 10679 3314 9992 11493 848 6016 7488 ... ## $ overall_satisfaction_100: num 90 0 80 90 100 100 0 80 0 90 ... airbnb &lt;- rename(airbnb, country = city, city = borough) # Diga ao R para renomear algumas variáveis do quadro de dados do airbnb e reatribuir esse novo quadro de dados ao objeto do airbnb. # Nota: a sintaxe é um pouco contra-intuitiva: novo nome de variável (country) = nome da variável antiga (city)! str(airbnb) # country = Bélgica agora e cidade se refere a cidades ## &#39;data.frame&#39;: 17651 obs. of 21 variables: ## $ room_id : int 5141135 13128333 8298885 13822088 18324301 12664969 15452889 3911778 14929414 8497852 ... ## $ host_id : int 20676997 46098805 30924336 81440431 14294054 68810179 99127166 3690027 30624501 40513093 ... ## $ room_type : chr &quot;Shared room&quot; &quot;Shared room&quot; &quot;Shared room&quot; &quot;Shared room&quot; ... ## $ country : chr &quot;Belgium&quot; &quot;Belgium&quot; &quot;Belgium&quot; &quot;Belgium&quot; ... ## $ city : chr &quot;Gent&quot; &quot;Brussel&quot; &quot;Brussel&quot; &quot;Oostende&quot; ... ## $ neighborhood : chr &quot;Gent&quot; &quot;Schaarbeek&quot; &quot;Elsene&quot; &quot;Middelkerke&quot; ... ## $ reviews : int 9 2 12 19 5 28 2 13 2 57 ... ## $ overall_satisfaction : num 4.5 0 4 4.5 5 5 0 4 0 4.5 ... ## $ accommodates : int 2 2 2 4 2 4 2 2 8 3 ... ## $ bedrooms : num 1 1 1 1 1 1 1 1 1 1 ... ## $ bathrooms : logi NA NA NA NA NA NA ... ## $ price : num 59 53 46 56 47 60 41 36 18 38 ... ## $ minstay : logi NA NA NA NA NA NA ... ## $ name : chr &quot;Spacious shared apartment in Gent&quot; &quot;appartement cosy&quot; &quot;YOU&#39;LL FEEL AT HOME!!!&quot; &quot;studio douillet pour un sÃ©jour \\&quot;Low-budget\\&quot;&quot; ... ## $ last_modified : chr &quot;2017-07-17 03:49:10.237453&quot; &quot;2017-07-17 03:49:09.020871&quot; &quot;2017-07-17 03:49:09.014704&quot; &quot;2017-07-17 03:49:07.929876&quot; ... ## $ latitude : num 51 50.9 50.8 51.2 50.8 ... ## $ longitude : num 3.71 4.38 4.38 2.82 4.33 ... ## $ location : chr &quot;0101000020E6100000D2C43BC093B60D40874F3A9160844940&quot; &quot;0101000020E610000044C02154A9891140321CCF67406F4940&quot; &quot;0101000020E6100000A80018CFA0811140BC404981056A4940&quot; &quot;0101000020E610000042E8A04B38940640AAF1D24D62984940&quot; ... ## $ room_id_F : Factor w/ 17651 levels &quot;2352&quot;,&quot;2354&quot;,..: 3018 9403 5877 10201 15058 9008 11815 2187 11309 6053 ... ## $ host_id_F : Factor w/ 13258 levels &quot;2582&quot;,&quot;6253&quot;,..: 4409 8169 6071 10679 3314 9992 11493 848 6016 7488 ... ## $ overall_satisfaction_100: num 90 0 80 90 100 100 0 80 0 90 ... Incluindo ou excluindo observações (linhas) Criando um vetor com c() Mais adiante, faremos um gráfico dos preços do Airbnb nas dez maiores cidades da Bélgica (em termos de população): Bruxelas, Antuérpia, Gent, Charleroi, Liège, Bruges, Namur, Lovaina, Mons e Aalst. Para isso, precisamos criar um objeto de dados que tenha apenas dados para as dez maiores cidades. Para fazer isso, primeiro precisamos de um vetor com os nomes das dez maiores cidades, para que, na próxima seção, possamos dizer ao R para incluir apenas os dados dessas cidades: topten &lt;- c(&quot;Brussel&quot;,&quot;Antwerpen&quot;,&quot;Gent&quot;,&quot;Charleroi&quot;,&quot;Liege&quot;,&quot;Brugge&quot;,&quot;Namur&quot;,&quot;Leuven&quot;,&quot;Mons&quot;,&quot;Aalst&quot;) # Cria um vetor com as 10 maiores cidades topten # Mostra esse vetor. ## [1] &quot;Brussel&quot; &quot;Antwerpen&quot; &quot;Gent&quot; &quot;Charleroi&quot; &quot;Liege&quot; &quot;Brugge&quot; &quot;Namur&quot; ## [8] &quot;Leuven&quot; &quot;Mons&quot; &quot;Aalst&quot; Lembre-se de que um vetor é uma estrutura de dados unidimensional (diferente de um quadro de dados que possui duas dimensões, isto é, colunas e linhas). Usamos o operador ) para criar um vetor que chamamos de topten. ) é uma abreviação de concatenar, que significa juntar as coisas. O vetor topten é um vetor de strings (palavras). Deve haver aspas entre as strings. Um vetor de números, no entanto, não requer aspas: number_vector &lt;- c(0,2,4,6) number_vector ## [1] 0 2 4 6 Qualquer vetor que você criará aparecerá como um objeto no painel Ambiente (janela superior direita). Incluindo ou excluindo observações com a função filter Para armazenar apenas os dados das dez maiores cidades, precisamos do operador %in% do pacote Hmisc: #install.packages(Hmisc) library(Hmisc) ## Loading required package: lattice ## Loading required package: survival ## Loading required package: Formula ## ## Attaching package: &#39;Hmisc&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## src, summarize ## The following objects are masked from &#39;package:base&#39;: ## ## format.pval, units Agora podemos usar a função de filtro para instruir o R a reter os dados apenas das dez maiores cidades: airbnb.topten &lt;- filter(airbnb, city %in% topten) # Filtre o quadro de dados do airbnb para manter apenas as cidades no vetor topten. # Armazene o conjunto de dados filtrado em um objeto chamado airbnb.topten. # Entao, estamos criando um novo conjunto de dados airbnb.topten, que eh um subconjunto do conjunto de dados airbnb. # Verifique o painel Ambiente para ver se o conjunto de dados airbnb.topten tem menos observacoes que o conjunto de dados airbnb, # porque soh possui dados para as dez maiores cidades. O operador pipe Uma maneira de escrever o código Até agora, aprendemos (entre outras coisas) como ler um arquivo .csv e atribuí-lo a um objeto, como transformar variáveis com a função mutate, como remover variáveis (colunas) do nosso conjunto de dados com a função select, como renomear variáveis com a função rename e como remover observações (linhas) do nosso conjunto de dados com a função de filter: #airbnb &lt;- read_csv(&quot;tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) #airbnb &lt;- mutate(airbnb, room_id_F = factor(room_id), host_id_F = factor(host_id), overall_satisfaction_100 = overall_satisfaction * 20) #airbnb &lt;- select(airbnb, -country, -survey_id) #airbnb &lt;- rename(airbnb, country = city, city = borough) #airbnb &lt;- filter(airbnb, city %in% c(&quot;Brussel&quot;,&quot;Antwerpen&quot;,&quot;Gent&quot;,&quot;Charleroi&quot;,&quot;Liege&quot;,&quot;Brugge&quot;,&quot;Namur&quot;,&quot;Leuven&quot;,&quot;Mons&quot;,&quot;Aalst&quot;)) Ao ler este código, vemos que em cada linha substituímos o objeto airbnb. Não há nada de fundamentalmente errado com essa maneira de escrever, mas estamos repetindo elementos do código porque as últimas quatro linhas consistem em uma atribuição (airbnb \\(&lt;-\\)) e em funções (mutate, select, rename, filter) que têm o mesmo primeiro argumento (o objeto airbnb criado na linha anterior). Uma maneira melhor de escrever seus códigos Existe uma maneira mais elegante de escrever código. Envolve um operador chamado pipe (\\(\\%&gt;\\%\\)). Ele nos permite reescrever nossa sequência usual de operações: #airbnb &lt;- read_csv(&quot;tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) #airbnb &lt;- mutate(airbnb, room_id_F = factor(room_id), host_id_F = factor(host_id), overall_satisfaction_100 = overall_satisfaction * 20) #airbnb &lt;- select(airbnb, -country, -survey_id) #airbnb &lt;- rename(airbnb, country = city, city = borough) #airbnb &lt;- filter(airbnb, city %in% c(&quot;Brussel&quot;,&quot;Antwerpen&quot;,&quot;Gent&quot;,&quot;Charleroi&quot;,&quot;Liege&quot;,&quot;Brugge&quot;,&quot;Namur&quot;,&quot;Leuven&quot;,&quot;Mons&quot;,&quot;Aalst&quot;)) como: airbnb &lt;- airbnb %&gt;% mutate(room_id_F = factor(room_id), host_id_F = factor(host_id), overall_satisfaction_100 = overall_satisfaction * 20) #%&gt;% #select(-country, -survey_id) %&gt;% #rename(country = city, city = borough) %&gt;% #filter(city %in% c(&quot;Brussel&quot;,&quot;Antwerpen&quot;,&quot;Gent&quot;,&quot;Charleroi&quot;,&quot;Liege&quot;,&quot;Brugge&quot;,&quot;Namur&quot;,&quot;Leuven&quot;,&quot;Mons&quot;,&quot;Aalst&quot;)) Isso pode ser lido de maneira natural: “leia o arquivo csv, depois faça a mutação, selecione, renomeie e depois filtre”. Começamos lendo um arquivo .csv. Em vez de armazená-lo em um objeto intermediário, fornecemos como o primeiro argumento para a função mutate usando o operador pipe: %\\(&gt;\\)%. É uma boa idéia aprender o atalho para %\\(&gt;\\)% de cór: Ctrl \\(+\\) Shift \\(+\\) M. A função mutate usa os mesmos argumentos acima (crie room_id_F, que deve ser uma fatoração de room_id, etc), mas agora não o fazemos precisamos fornecer o primeiro argumento (em qual conjunto de dados queremos que o mutate funcione). O primeiro argumento seria o quadro de dados resultante da leitura do arquivo .csv na linha anterior, mas isso é automaticamente transmitido como primeiro argumento a ser alterado pelo operador pipe. O operador pipe obtém a saída do que está no lado esquerdo do tubo e fornece isso como o primeiro argumento para o que está no lado direito do pipe (ou seja, a próxima linha de código). Depois de criar novas variáveis com mutate, descartamos algumas variáveis com select. Novamente, a função select usa os mesmos argumentos acima (soltar país e survey_id), mas não fornecemos o primeiro argumento (de qual conjunto de dados devemos retirar variáveis), porque ele já é fornecido pelo pipe na linha anterior. Continuamos da mesma maneira e renomeamos algumas variáveis com rename e descartamos algumas observações com o filter. A escrita de código com o operador de pipe explora a estrutura semelhante de mutate, select, rename, filter, que são as funções mais importantes para manipulação de dados. O primeiro argumento para todas essas funções é o quadro de dados no qual ela deve operar. Agora, esse primeiro argumento pode ser deixado de fora, porque é fornecido pelo operador pipe. No restante deste tutorial, escreveremos código usando o operador de pipe, pois melhora consideravelmente a legibilidade do nosso código. Agrupando e resumindo Vamos trabalhar no conjunto de dados completo novamente. Até agora, seu script deve ficar assim: library(tidyverse) #setwd(&quot;c:/Dropbox/work/teaching/R/data/&quot;) # Direciona seu diretorio de trabalho airbnb &lt;- airbnb %&gt;% mutate(room_id = factor(room_id), host_id = factor(host_id)) #%&gt;% # Nao criamos uma nova variavel room_id_F, mas substituimos room_id com sua fatoracao. O mesmo para host_id. #select(-country, -survey_id) %&gt;% # dropa country e survey_id #rename(country = city, city = borough) # renomeia city e borough # Deixamos de lado a transformacao da overall_satisfaction # e deixamos de fora o comando filter para garantir que nao retenhamos apenas os dados das dez cidades mais populosas Tabelas de frequência Cada observação em nosso conjunto de dados é uma sala ou quarto; portanto, sabemos que nossos dados contêm informações sobre 17651 quartos. Digamos que queremos saber quantos quartos existem por cidade: airbnb%&gt;% group_by(city)%&gt;% # Use a funcao group_by para agrupar o quadro de dados do airbnb (fornecido pelo pipe na linha anterior) por cidade summarise(nr_per_city = n()) # Resuma este objeto agrupado (fornecido pelo pipe na linha anterior): peca ao R para criar uma nova variavel nr_per_city que possua o numero de observacoes em cada grupo (cidade) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 43 x 2 ## city nr_per_city ## &lt;chr&gt; &lt;int&gt; ## 1 Aalst 74 ## 2 Antwerpen 1610 ## 3 Arlon 46 ## 4 Ath 47 ## 5 Bastogne 145 ## 6 Brugge 1094 ## 7 Brussel 6715 ## 8 Charleroi 118 ## 9 Dendermonde 45 ## 10 Diksmuide 27 ## # ... with 33 more rows Dizemos ao R para pegar o objeto airbnb, agrupá-lo por cidade e resumi-lo (summarise). O resumo que queremos é o número de observações por grupo. Nesse caso, as cidades formam os grupos. Os grupos sempre serão a primeira coluna em nossa saída. Obtemos o número de observações por grupo com a função n(). Esses números são armazenados em uma nova coluna denominada nr_per_city. Como você pode ver, essas frequências são classificadas em ordem alfabética por cidade. Em vez disso, podemos classificá-los pelo número de quartos por cidade: airbnb %&gt;% group_by(city) %&gt;% summarise(nr_per_city = n()) %&gt;% arrange(nr_per_city) # Usa a funcao arrange para classificar em uma coluna selecionada ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 43 x 2 ## city nr_per_city ## &lt;chr&gt; &lt;int&gt; ## 1 Tielt 24 ## 2 Diksmuide 27 ## 3 Moeskroen 28 ## 4 Roeselare 41 ## 5 Eeklo 43 ## 6 Dendermonde 45 ## 7 Arlon 46 ## 8 Ath 47 ## 9 Waremme 51 ## 10 Sint-Niklaas 52 ## # ... with 33 more rows Mostra a cidade com o menor número de quartos no topo. Para exibir a cidade com mais quartos no topo, classifique em ordem decrescente: airbnb %&gt;% group_by(city) %&gt;% summarise(nr_per_city = n()) %&gt;% arrange(desc(nr_per_city)) # Classifica por ordem descendente ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 43 x 2 ## city nr_per_city ## &lt;chr&gt; &lt;int&gt; ## 1 Brussel 6715 ## 2 Antwerpen 1610 ## 3 Gent 1206 ## 4 Brugge 1094 ## 5 LiÃ¨ge 667 ## 6 Verviers 631 ## 7 Oostende 527 ## 8 Nivelles 505 ## 9 Halle-Vilvoorde 471 ## 10 Leuven 434 ## # ... with 33 more rows Você verá que a capital Bruxelas tem mais quartos em oferta, seguidos por Antwerpen e Gent. Observe que isso é muito parecido com trabalhar com a Tabela Dinâmica no Excel. Você poderia ter feito tudo isso no Excel, mas isso tem várias desvantagens, especialmente ao trabalhar com grandes conjuntos de dados como o nosso: você não tem registro do que clicou, de como classificou os dados e do que pode ter copiado ou excluído. No Excel, é mais fácil cometer erros acidentais sem perceber do que no R. No R, você tem seu script, para poder voltar e verificar todas as etapas de sua análise. Nota: você também poderia ter feito isso sem o operador pipe: airbnb.grouped &lt;- group_by(airbnb, city) airbnb.grouped.summary &lt;- summarise(airbnb.grouped, nr_per_city = n()) ## `summarise()` ungrouping output (override with `.groups` argument) arrange(airbnb.grouped.summary, desc(nr_per_city)) ## # A tibble: 43 x 2 ## city nr_per_city ## &lt;chr&gt; &lt;int&gt; ## 1 Brussel 6715 ## 2 Antwerpen 1610 ## 3 Gent 1206 ## 4 Brugge 1094 ## 5 LiÃ¨ge 667 ## 6 Verviers 631 ## 7 Oostende 527 ## 8 Nivelles 505 ## 9 Halle-Vilvoorde 471 ## 10 Leuven 434 ## # ... with 33 more rows Mas espero que você concorde que o código que usa o operador de pipe é mais fácil de ler. Além disso, sem o operador pipe, você acabará criando muitos objetos desnecessários, como airbnb.grouped e airbnb.grouped.summary. Estatísticas Descritivas Digamos que, além das frequências por cidade, também desejemos o preço médio por cidade. Queremos que isso seja classificado em ordem decrescente pelo preço médio. Além disso, agora queremos armazenar as frequências e médias em um objeto (na seção anterior, não armazenamos a tabela de frequências em um objeto): airbnb.summary &lt;- airbnb %&gt;% # Armazena este resumo em um objeto chamado airbnb.summary. group_by(city) %&gt;% summarise(nr_per_city = n(), average_price = mean(price)) %&gt;% # Aqui informamos ao R para criar outra variavel chamada average_price que nos fornece a media dos precos por grupo (city) arrange(desc(average_price)) # Agora organiza por average_price e mostra o maior preco praticado dentre os demais ## `summarise()` ungrouping output (override with `.groups` argument) # Veja o painel de Ambiente para visualizar se ha agora um novo objeto chamado airbnb.summary. # Ao inves de apenas rodar airbnb.summary, # Eu o envolvi em um comando de print e defini n como Inf para ver todas as linhas. print(airbnb.summary, n = Inf) ## # A tibble: 43 x 3 ## city nr_per_city average_price ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Bastogne 145 181. ## 2 Philippeville 85 162. ## 3 Verviers 631 159. ## 4 Ieper 143 151. ## 5 Waremme 51 150. ## 6 Dinant 286 144. ## 7 Oudenaarde 110 142. ## 8 NeufchÃ¢teau 160 141. ## 9 Ath 47 134. ## 10 Tielt 24 129. ## 11 Tongeren 173 127. ## 12 Brugge 1094 126. ## 13 Huy 99 125. ## 14 Marche-en-Famenne 266 124. ## 15 Veurne 350 119. ## 16 Eeklo 43 115. ## 17 Diksmuide 27 114. ## 18 Moeskroen 28 113. ## 19 Mechelen 190 112. ## 20 Namur 286 111. ## 21 Thuin 81 107. ## 22 Kortrijk 107 103. ## 23 Oostende 527 102. ## 24 Hasselt 151 99.6 ## 25 Maaseik 93 98.1 ## 26 Antwerpen 1610 95.7 ## 27 Aalst 74 94.9 ## 28 Nivelles 505 94.1 ## 29 Gent 1206 90.5 ## 30 Sint-Niklaas 52 86.7 ## 31 Virton 56 86.5 ## 32 Tournai 97 86.4 ## 33 Halle-Vilvoorde 471 85.4 ## 34 Dendermonde 45 81.4 ## 35 Mons 129 79.3 ## 36 LiÃ¨ge 667 79.1 ## 37 Turnhout 130 78.1 ## 38 Soignies 58 77.7 ## 39 Charleroi 118 76.9 ## 40 Arlon 46 76.0 ## 41 Leuven 434 75.7 ## 42 Brussel 6715 75.1 ## 43 Roeselare 41 74.9 Talvez surpreendentemente, as três principais cidades mais caras são Bastogne, Philippeville e Verviers. Talvez o preço médio dessas cidades seja alto por causa de discrepâncias. Vamos calcular algumas estatísticas mais descritivas para ver se nosso palpite está correto: airbnb %&gt;% group_by(city) %&gt;% summarise(nr_per_city = n(), average_price = mean(price), median_price = median(price), # calcula a mediana dos precos por grupo (city) max_price = max(price)) %&gt;% # calcula o preco maximo por grupo (city) arrange(desc(median_price), desc(max_price)) # ordena em descendente pela mediana de preco entao pelo preco maximo ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 43 x 5 ## city nr_per_city average_price median_price max_price ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Tielt 24 129. 112 318 ## 2 Ieper 143 151. 111 695 ## 3 Verviers 631 159. 105 1769 ## 4 Brugge 1094 126. 105 1414 ## 5 Bastogne 145 181. 100 1650 ## 6 Veurne 350 119. 100 943 ## 7 Marche-en-Famenne 266 124. 100 472 ## 8 Dinant 286 144. 95 1284 ## 9 Tongeren 173 127. 95 990 ## 10 NeufchÃ¢teau 160 141. 95 872 ## # ... with 33 more rows Vemos que duas das três cidades com o preço médio mais alto (Verviers e Bastogne) também estão entre as cinco principais cidades com as medianas de preços; portanto, o seu preço médio alto não se deve apenas a alguns quartos com preços extremamente altos (embora tenham o preço mais alto, quartos nessas cidades são muito caros). Exportando (summaries) dos dados Às vezes, você pode querer exportar dados ou um resumo dos dados. Vamos salvar nossos dados ou resumo em um arquivo .csv (no Excel, podemos convertê-lo em um arquivo do Excel, se quisermos): # o primeiro argumento eh o objeto que voce deseja armazenar, o segundo eh o nome que voce deseja atribuir ao arquivo (nao esqueca a extensao .csv) # use write_csv2 quando voce tiver um computador belga (AZERTY), caso contrário, os números decimais não serão armazenados como números # armazenamento de dados write_excel_csv(airbnb, &quot;airbnb.csv&quot;) write_excel_csv2(airbnb, &quot;airbnb.csv&quot;) # armazenamento de summary write_excel_csv(airbnb.summary, &quot;airbnb_summary.csv&quot;) write_excel_csv2(airbnb.summary, &quot;airbnb_summary.csv&quot;) O arquivo será salvo no seu diretório de trabalho. Gráficos Faremos gráficos dos dados das dez cidades mais populosas da Bélgica. Se você possui o conjunto de dados completo do Airbnb em sua memória (verifique o painel Ambiente), basta filtrá-lo: airbnb.topten &lt;- airbnb %&gt;% filter(city %in% c(&quot;Brussel&quot;,&quot;Antwerpen&quot;,&quot;Gent&quot;,&quot;Charleroi&quot;,&quot;Liege&quot;,&quot;Brugge&quot;,&quot;Namur&quot;,&quot;Leuven&quot;,&quot;Mons&quot;,&quot;Aalst&quot;)) # lembre-se de que voce tera que carregar o pacote Hmisc para usar o operador %in%. Se você acabou de iniciar uma nova sessão R, também pode reler o arquivo .csv executando o código na seção da seção anterior. Diagrama de dispersão (scatterplot) Vamos criar um scatterplot dos preços por cidade: ggplot(data = airbnb.topten, mapping = aes(x = city, y = price)) + geom_point() Se tudo correr bem, uma plotagem deve aparecer no canto inferior direito da tela. As figuras são feitas com o comando ggplot. Na primeira linha, você diz ao ggplot quais dados devem ser usados para criar um gráfico e quais variáveis devem aparecer no eixo X e no eixo Y. Dizemos para colocar cidade no eixo X e preço no eixo Y. A especificação do eixo X e do eixo Y sempre deve vir como argumentos para uma função aes, que por sua vez é fornecida como um argumento para a função mapping (mapeamento). Na segunda linha, você diz ao ggplot para desenhar pontos (geom_point). Ao criar um gráfico, lembre-se de sempre adicionar um \\(+\\) no final de cada linha de código que compõe o gráfico, exceto o último (adicionar o \\(+\\) no início de uma linha não funcionará). O gráfico não é muito informativo porque muitos pontos são desenhados um sobre o outro. Jitter Vamos adicionar o gráfico do tipo jitter aos nossos pontos: ggplot(data = airbnb.topten, mapping = aes(x = city, y = price)) + geom_jitter() # O mesmo codigo de antes mas agora mudamos geom_point para geom_jitter. Em vez de solicitar pontos com geom_point(), agora solicitamos pontos com jitter adicionado com geom_jitter(). Jitter é um valor aleatório que é adicionado a cada coordenada X e Y, de modo que os pontos de dados não sejam desenhados um sobre o outro. Observe que fazemos isso apenas para tornar o gráfico mais informativo (compare-o com o gráfico de dispersão anterior, onde muitos pontos de dados são desenhados um sobre o outro); não altera os valores reais em nosso conjunto de dados. Histograma Ainda não está claro. Parece que a distribuição do preço está correta. Isso significa que a distribuição do preço não é normal. Uma distribuição normal tem dois recursos principais. Uma primeira característica é que existem mais valores próximos à média do que valores distantes da média. Em outras palavras, valores extremos não ocorrem com muita frequência. Uma segunda característica é que a distribuição é simétrica. Em outras palavras, o número de valores abaixo da média é igual ao número de valores acima da média. Em uma distribuição distorcida, existem valores extremos em apenas um lado da distribuição. No caso de inclinação à direita, isso significa que existem valores extremos no lado direito da distribuição. No nosso caso, isso significa que existem algumas listagens do Airbnb com preços muito altos. Isso aumenta a média da distribuição, de modo que as listagens não sejam mais normalmente distribuídas em torno da média. Vamos desenhar um histograma dos preços: ggplot(data = airbnb.topten, mapping = aes(x = price)) + # Observe que nao temos mais uma cidade x =. O preco deve estar no eixo X e as frequencias dos precos devem estar no eixo Y geom_histogram() # Eixo Y = frequencia dos valores no eixo X ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. De fato, existem alguns preços extremamente altos (em comparação com a maioria dos preços), portanto, os preços estão inclinados à direita. Nota: o stat_bin() usando compartimentos = 30. Escolha um valor melhor com o aviso de largura de caixa no console que possa ser ignorado com segurança. Transformação logarítmica Como a variável price está inclinada à direita, podemos transformá-la em log para torná-la mais normal: # No eixo y agora temos log(price, base=exp(1)) ao inves de price. log(price, base=exp(1)) = assuma o log natural, i.e., o log com base = exp(1) = e. ggplot(data = airbnb.topten, mapping = aes(x = city, y = log(price, base=exp(1)))) + geom_jitter() Plotando a mediana Vamos ter uma idéia melhor da mediana de preço por cidade: ggplot(data = airbnb.topten, mapping = aes(x = city, y = price)) + geom_jitter() + stat_summary(fun.y=median, colour=&quot;tomato3&quot;, size = 4, geom=&quot;point&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. A linha de código para obter a mediana pode ser lida da seguinte forma: stat_summary solicitará um resumo estatístico. A estatística que queremos é a mediana em uma cor chamada tomato3, com tamanho 4. Ela deve ser representada como um “ponto”. Vemos que Bruges é a cidade com o preço mediano mais alto. É muito mais fácil ver isso quando transformamos o preço por log: ggplot(data = airbnb.topten, mapping = aes(x = city, y = log(price, base = exp(1)))) + geom_jitter() + stat_summary(fun.y=median, colour=&quot;tomato3&quot;, size = 4, geom=&quot;point&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. Plotando a média Vamos adicionar a média também, mas com uma cor e forma diferentes da média: ggplot(data = airbnb.topten, mapping = aes(x = city, y = log(price, base = exp(1)))) + geom_jitter() + stat_summary(fun.y=median, colour=&quot;tomato3&quot;, size = 4, geom=&quot;point&quot;) + stat_summary(fun.y=mean, colour=&quot;green&quot;, size = 4, geom=&quot;point&quot;, shape = 23, fill = &quot;green&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. ## Warning: `fun.y` is deprecated. Use `fun` instead. O código para obter a média é muito semelhante ao usado para obter a mediana. Simplesmente alteramos a estatística, a cor e adicionamos a forma =23 para obter diamantes em vez de círculos e preencher =green para preencher os diamantes (pontos do gráfico). Vemos que os meios e medianas são bastante semelhantes. Salvando imagens Podemos salvar esse gráfico em nosso disco rígido. Para fazer isso, clique em Exportar / Salvar como imagem. Se você não alterar o diretório, o arquivo será salvo no seu diretório de trabalho. Você pode redimensionar a plotagem e também fornecer um nome de arquivo significativo - Rplot01.png não será útil quando você tentar encontrar o arquivo posteriormente. Uma maneira diferente (reproduzível) de salvar seu arquivo é agrupar o código nas funções png() e dev.off(): png(&quot;price_per_city.png&quot;, width=800, height=600) # Isso ira preparar o R para salvar o grafico a seguir. # Fornece um nome de arquivo e dimensoes para largura e altura da figura em pixels ggplot(data = airbnb.topten, mapping = aes(x = city, log(price, base = exp(1)))) + geom_jitter() + stat_summary(fun.y=mean, colour=&quot;green&quot;, size = 4, geom=&quot;point&quot;, shape = 23, fill = &quot;green&quot;) # Somente mantivemos a media aqui ## Warning: `fun.y` is deprecated. Use `fun` instead. dev.off() # Isso dira ao R que terminamos a plotagem e que ela deve salvar a plotagem no disco rigido. ## png ## 2 Embora o R tenha uma interface não gráfica, ele pode criar gráficos muito bons. Praticamente todos os pequenos detalhes no gráfico podem ser ajustados. Muitos dos gráficos que você vê em “jornalismo de dados” (por exemplo, em https://www.nytimes.com/ ou em http://fivethirtyeight.com/ são feitos em R.) "],
["análise-básica-de-dados-analisando-dados-secundários.html", "Análise básica de dados: analisando dados secundários Dados", " Análise básica de dados: analisando dados secundários Neste capítulo, analisaremos os dados do Airbnb.com. A introdução tem mais informações sobre esses dados. Dados Importação Você pode baixar o conjunto de dados clicando com o botão direito do mouse nesse link, selecionando “Salvar link como…” (ou algo semelhante) e salvando o arquivo .csv em um diretório no disco rígido. Como mencionado na introdução, é uma boa ideia salvar seu trabalho em um diretório que é automaticamente copiado pelo software de compartilhamento de arquivos. Vamos importar os dados: library(tidyverse) #setwd(&quot;c:/Dropbox/work/teaching/R/&quot;) # Ajusta seu diretorio de trabalho airbnb &lt;- read.csv(file=&quot;http://users.telenet.be/samuelfranssens/tutorial_data/tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) %&gt;% mutate(room_id = factor(room_id), host_id = factor(host_id)) %&gt;% select(-country, -survey_id) %&gt;% # dropa country &amp; survey_id, veja a introdução de por que fazemos isso rename(country = city, city = borough) # renomeia city &amp; borough, veja a introdução de por que fazemos isso Não se esqueça de salvar seu script no diretório de trabalho. Manipulação Se você abrir o quadro de dados do airbnb em uma guia do Visualizador, verá que os bathrooms e o minstay são colunas vazias e que o local e last_modified não são muito informativos. Vamos remover estas variáveis: airbnb &lt;- airbnb %&gt;% select (-bathrooms, -minstay, -location, -last_modified) Agora, dê uma olhada na variável overall_satisfaction: # use head() para imprimir apenas os primeiros valores de um vetor, para evitar uma lista muito longa # tail() imprime apenas os últimos valores de um vetor head(airbnb$overall_satisfaction) ## [1] 4.5 0.0 4.0 4.5 5.0 5.0 A segunda classificação é zero. Provavelmente, isso significa que a classificação está faltando, em vez de ser realmente zero. Vamos substituir os valores zero na overall_satisfaction por NA: airbnb &lt;- airbnb %&gt;% mutate(overall_satisfaction = replace(overall_satisfaction, overall_satisfaction == 0, NA)) # crie uma variavel &quot;nova&quot; overall_satisfaction que seja igual a overall_satisfaction com valores de NA em que overall_satisfaction seja igual a zero. # Digamos que desejassemos substituir NA por 0, entao o comando se tornaria: substitute(overall_satisfaction, is.na(overall_satisfaction), 0) # overall_satisfaction == NA nao funciona head(airbnb$overall_satisfaction) ## [1] 4.5 NA 4.0 4.5 5.0 5.0 Mesclando datasets Posteriormente, testaremos se o preço está relacionado a determinadas características dos tipos de quartos. As características potencialmente interessantes são: room_type, city, reviews, overall_satisfaction, etc. Para torná-lo ainda mais interessante, podemos aumentar os dados, por exemplo, com dados disponíveis publicamente nas cidades. Reuni os tamanhos de população das cidades belgas mais populosas deste site. Faça o download desses dados (aqui) e importe-os para o R: #population &lt;- read_excel(&quot;population.xlsx&quot;,&quot;data&quot;) library(readxl) url&lt;-&quot;http://users.telenet.be/samuelfranssens/tutorial_data/population.xlsx&quot; population &lt;- tempfile() download.file(url, population, mode=&quot;wb&quot;) population&lt;-read_excel(path = population, sheet = 1) population ## # A tibble: 183 x 2 ## place population ## &lt;chr&gt; &lt;dbl&gt; ## 1 Brussels 1019022 ## 2 Antwerpen 459805 ## 3 Gent 231493 ## 4 Charleroi 200132 ## 5 Liège 182597 ## 6 Brugge 116709 ## 7 Namur 106284 ## 8 Leuven 92892 ## 9 Mons 91277 ## 10 Aalst 77534 ## # ... with 173 more rows Agora, queremos vincular esses dados ao nosso quadro de dados do airbnb. Isso é muito fácil no R (mas é muito difícil, por exemplo, no Excel): airbnb.merged &lt;- left_join(airbnb, population, by = c(&quot;city&quot; = &quot;place&quot;)) # o primeiro argumento eh o conjunto de dados que queremos aumentar # o segundo argumento eh onde encontramos os dados para aumentar o primeiro conjunto de dados com # o terceiro argumento sao as variaveis que usamos para vincular um conjunto de dados ao outro (cidade eh uma variavel no airbnb, local eh uma variavel na populacao) Confira as colunas mais relevantes do quadro de dados airbnb.merged: airbnb.merged %&gt;% select(room_id, city, price, population) ## room_id city price population ## 1 5141135 Gent 59 231493 ## 2 13128333 Brussel 53 NA ## 3 8298885 Brussel 46 NA ## 4 13822088 Oostende 56 NA ## 5 18324301 Brussel 47 NA ## 6 12664969 Brussel 60 NA ## 7 15452889 Gent 41 231493 ## 8 3911778 Brussel 36 NA ## 9 14929414 Verviers 18 52824 ## 10 8497852 Brussel 38 NA ## 11 19372053 Tournai 14 67721 ## 12 19855549 Brussel 37 NA ## 13 6772358 Gent 28 231493 ## 14 13852832 Arlon 177 26179 ## 15 11581251 Kortrijk 147 73879 ## 16 3645177 Antwerpen 177 459805 ## 17 12032748 Verviers 129 52824 ## 18 12034268 Verviers 140 52824 ## 19 427739 Gent 141 231493 ## 20 14194882 Brussel 136 NA ## 21 19298546 Leuven 132 92892 ## 22 12133666 Brugge 117 116709 ## 23 4419833 Ath 106 26681 ## 24 15573750 Leuven 116 92892 ## 25 1334575 Tongeren 106 29816 ## 26 5080373 Leuven 117 92892 ## 27 18792208 Brussel 95 NA ## 28 12953046 Turnhout 95 39654 ## 29 19240451 Brussel 89 NA ## 30 18127715 Brussel 90 NA ## 31 2819790 Antwerpen 99 459805 ## 32 13359912 Brugge 95 116709 ## 33 19011766 Dinant 89 NA ## 34 18400286 Nivelles 100 24149 ## 35 6618531 Tongeren 79 29816 ## 36 5295379 Brussel 70 NA ## 37 305254 Brussel 65 NA ## 38 17101078 Brussel 68 NA ## 39 6922628 Antwerpen 71 459805 ## 40 6071151 Leuven 82 92892 ## 41 776659 Verviers 70 52824 ## 42 7264367 Antwerpen 71 459805 ## 43 9872230 Antwerpen 71 459805 ## 44 9374612 Brussel 82 NA ## 45 16487370 Mechelen 64 77530 ## 46 14904339 Namur 64 106284 ## 47 10134272 Brussel 82 NA ## 48 5369431 Brussel 47 NA ## 49 14269765 Brussel 46 NA ## 50 9428708 LiÃ¨ge 47 NA ## 51 18412932 Brussel 47 NA ## 52 15867878 Oostende 59 NA ## 53 8669953 Halle-Vilvoorde 53 NA ## 54 6137734 Mechelen 59 77530 ## 55 13917474 LiÃ¨ge 53 NA ## 56 15325813 Gent 42 231493 ## 57 18855915 Virton 53 NA ## 58 19257027 Turnhout 47 39654 ## 59 11984885 Brussel 47 NA ## 60 7982955 Brussel 53 NA ## 61 2289786 Antwerpen 41 459805 ## 62 17822696 Verviers 44 52824 ## 63 19644516 Mechelen 58 77530 ## 64 2403914 Antwerpen 47 459805 ## 65 3503685 Brussel 53 NA ## 66 1334717 Tongeren 47 29816 ## 67 7479719 Mechelen 41 77530 ## 68 5609860 Nivelles 44 24149 ## 69 17306887 Mons 43 91277 ## 70 8422305 Oostende 41 NA ## 71 19539445 Brussel 59 NA ## 72 11683593 Brussel 47 NA ## 73 19267790 Brussel 47 NA ## 74 13870594 Antwerpen 53 459805 ## 75 17991836 Mechelen 59 77530 ## 76 15563196 Brussel 30 NA ## 77 15138720 Brussel 34 NA ## 78 14481075 Brussel 18 NA ## 79 15453651 Brussel 30 NA ## 80 6504321 Brussel 30 NA ## 81 8209254 Halle-Vilvoorde 41 NA ## 82 16453691 Verviers 11 52824 ## 83 16307457 Tongeren 35 29816 ## 84 16626065 Brussel 35 NA ## 85 14264551 Brussel 26 NA ## 86 13879762 Soignies 22 24869 ## 87 12424835 Brussel 40 NA ## 88 12032916 Gent 23 231493 ## 89 12101635 Leuven 39 92892 ## 90 10625332 Brussel 30 NA ## 91 12424357 Brussel 40 NA ## 92 3710876 Antwerpen 35 459805 ## 93 10128019 Antwerpen 31 459805 ## 94 7186272 Brussel 24 NA ## 95 19242190 Aalst 11 77534 ## 96 17128648 Verviers 18 52824 ## 97 10079396 Brussel 26 NA ## 98 16775210 Brussel 23 NA ## 99 19794790 Brussel 23 NA ## 100 15459733 Brussel 19 NA ## 101 2533747 Brussel 39 NA ## 102 16486024 Brussel 19 NA ## 103 19082765 Brussel 19 NA ## 104 13838407 Brussel 26 NA ## 105 15459583 Brussel 19 NA ## 106 18365341 Oudenaarde 24 27935 ## 107 18303344 Brussel 22 NA ## 108 13856670 Brussel 24 NA ## 109 13846466 Brussel 30 NA ## 110 5208612 Brussel 125 NA ## 111 5867005 Brussel 136 NA ## 112 16234918 Brussel 133 NA ## 113 627461 Brussel 115 NA ## 114 4029308 Arlon 106 26179 ## 115 4964759 Brussel 105 NA ## 116 19886292 Halle-Vilvoorde 124 NA ## 117 15651530 Brussel 89 NA ## 118 12282191 Veurne 82 NA ## 119 9482000 Oostende 100 NA ## 120 18669717 Arlon 65 26179 ## 121 6618877 Brussel 70 NA ## 122 18848502 Brussel 76 NA ## 123 7508044 Brussel 59 NA ## 124 19868373 Gent 62 231493 ## 125 13384698 Brussel 59 NA ## 126 9044335 Brussel 47 NA ## 127 14314490 Brussel 59 NA ## 128 13061326 Brussel 49 NA ## 129 13052188 Brussel 59 NA ## 130 7997565 Brussel 59 NA ## 131 17116772 Brussel 49 NA ## 132 7799636 Brussel 1120 NA ## 133 8288800 Namur 1061 106284 ## 134 14400013 NeufchÃ¢teau 872 NA ## 135 17081519 Waremme 866 NA ## 136 5634567 LiÃ¨ge 825 NA ## 137 7805577 Verviers 884 52824 ## 138 7165868 Brussel 1002 NA ## 139 10274258 Verviers 1002 52824 ## 140 8122542 NeufchÃ¢teau 814 NA ## 141 17862238 Verviers 630 52824 ## 142 8638355 Brugge 530 116709 ## 143 14361938 Verviers 708 52824 ## 144 6584668 Antwerpen 531 459805 ## 145 12659483 Verviers 530 52824 ## 146 1133543 Dinant 589 NA ## 147 9289185 Brussel 708 NA ## 148 5268112 Kortrijk 530 73879 ## 149 16511250 Verviers 708 52824 ## 150 18055247 Antwerpen 589 459805 ## 151 4125959 Verviers 613 52824 ## 152 19832075 Antwerpen 589 459805 ## 153 9895516 Verviers 589 52824 ## 154 11311977 Oudenaarde 588 27935 ## 155 19767542 Antwerpen 589 459805 ## 156 2001980 Ieper 648 35089 ## 157 19544556 Mechelen 565 77530 ## 158 17094009 Namur 648 106284 ## 159 6266731 Marche-en-Famenne 342 16856 ## 160 6306984 Marche-en-Famenne 459 16856 ## 161 1873941 Namur 353 106284 ## 162 10505318 Brugge 353 116709 ## 163 3218980 Leuven 324 92892 ## 164 6622480 Brugge 383 116709 ## 165 14436744 Verviers 413 52824 ## 166 4643394 Dinant 388 NA ## 167 8305745 Tongeren 324 29816 ## 168 14563219 Brugge 330 116709 ## 169 8605552 Antwerpen 413 459805 ## 170 9768597 Brugge 413 116709 ## 171 10982966 Dinant 401 NA ## 172 13890965 Sint-Niklaas 483 69010 ## 173 9485806 NeufchÃ¢teau 211 NA ## 174 14139756 Dinant 260 NA ## 175 8677551 NeufchÃ¢teau 227 NA ## 176 5062155 Marche-en-Famenne 272 16856 ## 177 7631501 NeufchÃ¢teau 212 NA ## 178 11965718 Ieper 236 35089 ## 179 2873179 Brussel 271 NA ## 180 8081545 Brussel 236 NA ## 181 2200868 Brugge 235 116709 ## 182 18670282 Brugge 236 116709 ## 183 6431470 Brugge 218 116709 ## 184 9856241 Brugge 260 116709 ## 185 3320199 Brussel 236 NA ## 186 9177354 Brussel 224 NA ## 187 7574537 Marche-en-Famenne 247 16856 ## 188 4053396 Brussel 76 NA ## 189 10790061 Antwerpen 68 459805 ## 190 9871590 Antwerpen 78 459805 ## 191 3879691 Brugge 76 116709 ## 192 18496589 Antwerpen 77 459805 ## 193 12567023 Brussel 265 NA ## 194 5158233 Dinant 236 NA ## 195 10045822 Brugge 236 116709 ## 196 7570229 Marche-en-Famenne 212 16856 ## 197 19875796 Antwerpen 271 459805 ## 198 19799071 Brussel 212 NA ## 199 14213309 Antwerpen 230 459805 ## 200 19880328 Halle-Vilvoorde 265 NA ## 201 2643209 Brussel 201 NA ## 202 19420094 Veurne 201 NA ## 203 19357024 Veurne 188 NA ## 204 5456149 Oostende 201 NA ## 205 14027383 LiÃ¨ge 188 NA ## 206 1457964 Brussel 188 NA ## 207 8177441 Verviers 203 52824 ## 208 6653065 Nivelles 206 24149 ## 209 15322863 Gent 141 231493 ## 210 14414584 Veurne 130 NA ## 211 19869653 Moeskroen 141 NA ## 212 14313831 Brugge 133 116709 ## 213 6420828 Verviers 140 52824 ## 214 14663508 Verviers 141 52824 ## 215 4234316 Brugge 141 116709 ## 216 11753766 Dinant 136 NA ## 217 19841063 Antwerpen 136 459805 ## 218 5752406 NeufchÃ¢teau 117 NA ## 219 7225096 LiÃ¨ge 116 NA ## 220 4460348 Arlon 106 26179 ## 221 18176029 Arlon 106 26179 ## 222 4595400 Gent 111 231493 ## 223 9527419 Veurne 123 NA ## 224 2855704 Gent 106 231493 ## 225 9438769 LiÃ¨ge 112 NA ## 226 19586893 Verviers 116 52824 ## 227 19873275 Soignies 106 24869 ## 228 19867106 Brussel 117 NA ## 229 9687262 Brussel 116 NA ## 230 19887471 Brussel 106 NA ## 231 18958135 Maaseik 112 23684 ## 232 19882564 Brussel 117 NA ## 233 16485966 Brussel 19 NA ## 234 15513008 Brussel 19 NA ## 235 19101520 Brussel 18 NA ## 236 15542284 Brussel 19 NA ## 237 16688487 Halle-Vilvoorde 30 NA ## 238 18985088 Brussel 19 NA ## 239 8906556 Brussel 26 NA ## 240 11278553 Virton 30 NA ## 241 5866814 Namur 27 106284 ## 242 19782106 Brussel 24 NA ## 243 10571855 Brussel 18 NA ## 244 6894473 Brugge 28 116709 ## 245 19423405 Brussel 24 NA ## 246 2820108 Antwerpen 35 459805 ## 247 5813507 Leuven 28 92892 ## 248 15176439 LiÃ¨ge 24 NA ## 249 19685432 Brussel 30 NA ## 250 19082608 Brussel 19 NA ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 17401 rows ] Vemos que há uma population de colunas em nosso conjunto de dados airbnb.merged. Você também pode ver isso no painel Ambiente: airbnb.merged tem uma variável a mais que airbnb (mas o mesmo número de observações). Faltam dados para Bruxelas, no entanto. Isso ocorre porque Bruxelas está escrito em holandês no conjunto de dados airbnb, mas em inglês no conjunto de dados da population. Vamos substituir Bruxelas por Bruxelas no conjunto de dados da population (e também alterar a ortografia de duas outras cidades) e vincular os dados novamente: population &lt;- population %&gt;% mutate(place = replace(place, place == &quot;Brussels&quot;, &quot;Brussel&quot;), place = replace(place, place == &quot;Ostend&quot;, &quot;Oostende&quot;), place = replace(place, place == &quot;Mouscron&quot;, &quot;Moeskroen&quot;)) airbnb.merged &lt;- left_join(airbnb, population, by = c(&quot;city&quot; = &quot;place&quot;)) airbnb.merged %&gt;% select(room_id, city, price, population) ## room_id city price population ## 1 5141135 Gent 59 231493 ## 2 13128333 Brussel 53 1019022 ## 3 8298885 Brussel 46 1019022 ## 4 13822088 Oostende 56 69011 ## 5 18324301 Brussel 47 1019022 ## 6 12664969 Brussel 60 1019022 ## 7 15452889 Gent 41 231493 ## 8 3911778 Brussel 36 1019022 ## 9 14929414 Verviers 18 52824 ## 10 8497852 Brussel 38 1019022 ## 11 19372053 Tournai 14 67721 ## 12 19855549 Brussel 37 1019022 ## 13 6772358 Gent 28 231493 ## 14 13852832 Arlon 177 26179 ## 15 11581251 Kortrijk 147 73879 ## 16 3645177 Antwerpen 177 459805 ## 17 12032748 Verviers 129 52824 ## 18 12034268 Verviers 140 52824 ## 19 427739 Gent 141 231493 ## 20 14194882 Brussel 136 1019022 ## 21 19298546 Leuven 132 92892 ## 22 12133666 Brugge 117 116709 ## 23 4419833 Ath 106 26681 ## 24 15573750 Leuven 116 92892 ## 25 1334575 Tongeren 106 29816 ## 26 5080373 Leuven 117 92892 ## 27 18792208 Brussel 95 1019022 ## 28 12953046 Turnhout 95 39654 ## 29 19240451 Brussel 89 1019022 ## 30 18127715 Brussel 90 1019022 ## 31 2819790 Antwerpen 99 459805 ## 32 13359912 Brugge 95 116709 ## 33 19011766 Dinant 89 NA ## 34 18400286 Nivelles 100 24149 ## 35 6618531 Tongeren 79 29816 ## 36 5295379 Brussel 70 1019022 ## 37 305254 Brussel 65 1019022 ## 38 17101078 Brussel 68 1019022 ## 39 6922628 Antwerpen 71 459805 ## 40 6071151 Leuven 82 92892 ## 41 776659 Verviers 70 52824 ## 42 7264367 Antwerpen 71 459805 ## 43 9872230 Antwerpen 71 459805 ## 44 9374612 Brussel 82 1019022 ## 45 16487370 Mechelen 64 77530 ## 46 14904339 Namur 64 106284 ## 47 10134272 Brussel 82 1019022 ## 48 5369431 Brussel 47 1019022 ## 49 14269765 Brussel 46 1019022 ## 50 9428708 LiÃ¨ge 47 NA ## 51 18412932 Brussel 47 1019022 ## 52 15867878 Oostende 59 69011 ## 53 8669953 Halle-Vilvoorde 53 NA ## 54 6137734 Mechelen 59 77530 ## 55 13917474 LiÃ¨ge 53 NA ## 56 15325813 Gent 42 231493 ## 57 18855915 Virton 53 NA ## 58 19257027 Turnhout 47 39654 ## 59 11984885 Brussel 47 1019022 ## 60 7982955 Brussel 53 1019022 ## 61 2289786 Antwerpen 41 459805 ## 62 17822696 Verviers 44 52824 ## 63 19644516 Mechelen 58 77530 ## 64 2403914 Antwerpen 47 459805 ## 65 3503685 Brussel 53 1019022 ## 66 1334717 Tongeren 47 29816 ## 67 7479719 Mechelen 41 77530 ## 68 5609860 Nivelles 44 24149 ## 69 17306887 Mons 43 91277 ## 70 8422305 Oostende 41 69011 ## 71 19539445 Brussel 59 1019022 ## 72 11683593 Brussel 47 1019022 ## 73 19267790 Brussel 47 1019022 ## 74 13870594 Antwerpen 53 459805 ## 75 17991836 Mechelen 59 77530 ## 76 15563196 Brussel 30 1019022 ## 77 15138720 Brussel 34 1019022 ## 78 14481075 Brussel 18 1019022 ## 79 15453651 Brussel 30 1019022 ## 80 6504321 Brussel 30 1019022 ## 81 8209254 Halle-Vilvoorde 41 NA ## 82 16453691 Verviers 11 52824 ## 83 16307457 Tongeren 35 29816 ## 84 16626065 Brussel 35 1019022 ## 85 14264551 Brussel 26 1019022 ## 86 13879762 Soignies 22 24869 ## 87 12424835 Brussel 40 1019022 ## 88 12032916 Gent 23 231493 ## 89 12101635 Leuven 39 92892 ## 90 10625332 Brussel 30 1019022 ## 91 12424357 Brussel 40 1019022 ## 92 3710876 Antwerpen 35 459805 ## 93 10128019 Antwerpen 31 459805 ## 94 7186272 Brussel 24 1019022 ## 95 19242190 Aalst 11 77534 ## 96 17128648 Verviers 18 52824 ## 97 10079396 Brussel 26 1019022 ## 98 16775210 Brussel 23 1019022 ## 99 19794790 Brussel 23 1019022 ## 100 15459733 Brussel 19 1019022 ## 101 2533747 Brussel 39 1019022 ## 102 16486024 Brussel 19 1019022 ## 103 19082765 Brussel 19 1019022 ## 104 13838407 Brussel 26 1019022 ## 105 15459583 Brussel 19 1019022 ## 106 18365341 Oudenaarde 24 27935 ## 107 18303344 Brussel 22 1019022 ## 108 13856670 Brussel 24 1019022 ## 109 13846466 Brussel 30 1019022 ## 110 5208612 Brussel 125 1019022 ## 111 5867005 Brussel 136 1019022 ## 112 16234918 Brussel 133 1019022 ## 113 627461 Brussel 115 1019022 ## 114 4029308 Arlon 106 26179 ## 115 4964759 Brussel 105 1019022 ## 116 19886292 Halle-Vilvoorde 124 NA ## 117 15651530 Brussel 89 1019022 ## 118 12282191 Veurne 82 NA ## 119 9482000 Oostende 100 69011 ## 120 18669717 Arlon 65 26179 ## 121 6618877 Brussel 70 1019022 ## 122 18848502 Brussel 76 1019022 ## 123 7508044 Brussel 59 1019022 ## 124 19868373 Gent 62 231493 ## 125 13384698 Brussel 59 1019022 ## 126 9044335 Brussel 47 1019022 ## 127 14314490 Brussel 59 1019022 ## 128 13061326 Brussel 49 1019022 ## 129 13052188 Brussel 59 1019022 ## 130 7997565 Brussel 59 1019022 ## 131 17116772 Brussel 49 1019022 ## 132 7799636 Brussel 1120 1019022 ## 133 8288800 Namur 1061 106284 ## 134 14400013 NeufchÃ¢teau 872 NA ## 135 17081519 Waremme 866 NA ## 136 5634567 LiÃ¨ge 825 NA ## 137 7805577 Verviers 884 52824 ## 138 7165868 Brussel 1002 1019022 ## 139 10274258 Verviers 1002 52824 ## 140 8122542 NeufchÃ¢teau 814 NA ## 141 17862238 Verviers 630 52824 ## 142 8638355 Brugge 530 116709 ## 143 14361938 Verviers 708 52824 ## 144 6584668 Antwerpen 531 459805 ## 145 12659483 Verviers 530 52824 ## 146 1133543 Dinant 589 NA ## 147 9289185 Brussel 708 1019022 ## 148 5268112 Kortrijk 530 73879 ## 149 16511250 Verviers 708 52824 ## 150 18055247 Antwerpen 589 459805 ## 151 4125959 Verviers 613 52824 ## 152 19832075 Antwerpen 589 459805 ## 153 9895516 Verviers 589 52824 ## 154 11311977 Oudenaarde 588 27935 ## 155 19767542 Antwerpen 589 459805 ## 156 2001980 Ieper 648 35089 ## 157 19544556 Mechelen 565 77530 ## 158 17094009 Namur 648 106284 ## 159 6266731 Marche-en-Famenne 342 16856 ## 160 6306984 Marche-en-Famenne 459 16856 ## 161 1873941 Namur 353 106284 ## 162 10505318 Brugge 353 116709 ## 163 3218980 Leuven 324 92892 ## 164 6622480 Brugge 383 116709 ## 165 14436744 Verviers 413 52824 ## 166 4643394 Dinant 388 NA ## 167 8305745 Tongeren 324 29816 ## 168 14563219 Brugge 330 116709 ## 169 8605552 Antwerpen 413 459805 ## 170 9768597 Brugge 413 116709 ## 171 10982966 Dinant 401 NA ## 172 13890965 Sint-Niklaas 483 69010 ## 173 9485806 NeufchÃ¢teau 211 NA ## 174 14139756 Dinant 260 NA ## 175 8677551 NeufchÃ¢teau 227 NA ## 176 5062155 Marche-en-Famenne 272 16856 ## 177 7631501 NeufchÃ¢teau 212 NA ## 178 11965718 Ieper 236 35089 ## 179 2873179 Brussel 271 1019022 ## 180 8081545 Brussel 236 1019022 ## 181 2200868 Brugge 235 116709 ## 182 18670282 Brugge 236 116709 ## 183 6431470 Brugge 218 116709 ## 184 9856241 Brugge 260 116709 ## 185 3320199 Brussel 236 1019022 ## 186 9177354 Brussel 224 1019022 ## 187 7574537 Marche-en-Famenne 247 16856 ## 188 4053396 Brussel 76 1019022 ## 189 10790061 Antwerpen 68 459805 ## 190 9871590 Antwerpen 78 459805 ## 191 3879691 Brugge 76 116709 ## 192 18496589 Antwerpen 77 459805 ## 193 12567023 Brussel 265 1019022 ## 194 5158233 Dinant 236 NA ## 195 10045822 Brugge 236 116709 ## 196 7570229 Marche-en-Famenne 212 16856 ## 197 19875796 Antwerpen 271 459805 ## 198 19799071 Brussel 212 1019022 ## 199 14213309 Antwerpen 230 459805 ## 200 19880328 Halle-Vilvoorde 265 NA ## 201 2643209 Brussel 201 1019022 ## 202 19420094 Veurne 201 NA ## 203 19357024 Veurne 188 NA ## 204 5456149 Oostende 201 69011 ## 205 14027383 LiÃ¨ge 188 NA ## 206 1457964 Brussel 188 1019022 ## 207 8177441 Verviers 203 52824 ## 208 6653065 Nivelles 206 24149 ## 209 15322863 Gent 141 231493 ## 210 14414584 Veurne 130 NA ## 211 19869653 Moeskroen 141 52069 ## 212 14313831 Brugge 133 116709 ## 213 6420828 Verviers 140 52824 ## 214 14663508 Verviers 141 52824 ## 215 4234316 Brugge 141 116709 ## 216 11753766 Dinant 136 NA ## 217 19841063 Antwerpen 136 459805 ## 218 5752406 NeufchÃ¢teau 117 NA ## 219 7225096 LiÃ¨ge 116 NA ## 220 4460348 Arlon 106 26179 ## 221 18176029 Arlon 106 26179 ## 222 4595400 Gent 111 231493 ## 223 9527419 Veurne 123 NA ## 224 2855704 Gent 106 231493 ## 225 9438769 LiÃ¨ge 112 NA ## 226 19586893 Verviers 116 52824 ## 227 19873275 Soignies 106 24869 ## 228 19867106 Brussel 117 1019022 ## 229 9687262 Brussel 116 1019022 ## 230 19887471 Brussel 106 1019022 ## 231 18958135 Maaseik 112 23684 ## 232 19882564 Brussel 117 1019022 ## 233 16485966 Brussel 19 1019022 ## 234 15513008 Brussel 19 1019022 ## 235 19101520 Brussel 18 1019022 ## 236 15542284 Brussel 19 1019022 ## 237 16688487 Halle-Vilvoorde 30 NA ## 238 18985088 Brussel 19 1019022 ## 239 8906556 Brussel 26 1019022 ## 240 11278553 Virton 30 NA ## 241 5866814 Namur 27 106284 ## 242 19782106 Brussel 24 1019022 ## 243 10571855 Brussel 18 1019022 ## 244 6894473 Brugge 28 116709 ## 245 19423405 Brussel 24 1019022 ## 246 2820108 Antwerpen 35 459805 ## 247 5813507 Leuven 28 92892 ## 248 15176439 LiÃ¨ge 24 NA ## 249 19685432 Brussel 30 1019022 ## 250 19082608 Brussel 19 1019022 ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 17401 rows ] Recapitulando: importação e manipulação Aqui está o que fizemos até agora, em uma sequência ordenada de operações pipe (faça o download dos dados aqui e aqui: #library(tidyverse) #setwd(&quot;c:/Dropbox/work/teaching/R&quot;) # Configura seu diretorio de trabalho #airbnb &lt;- read_csv(&quot;tomslee_airbnb_belgium_1454_2017-07-14.csv&quot;) %&gt;% #mutate(room_id = factor(room_id), host_id = factor(host_id), # overall_satisfaction = replace(overall_satisfaction, overall_satisfaction == 0, NA)) %&gt;% # select(-country, -survey_id,- bathrooms, -minstay, -location, -last_modified) %&gt;% # rename(country = city, city = borough) #population &lt;- read_excel(&quot;population.xlsx&quot;,&quot;data&quot;) %&gt;% #mutate(place = replace(place, place == &quot;Brussels&quot;, &quot;Brussel&quot;), # place = replace(place, place == &quot;Ostend&quot;, &quot;Oostende&quot;), # place = replace(place, place == &quot;Mouscron&quot;, &quot;Moeskroen&quot;)) #airbnb &lt;- left_join(airbnb, population, by = c(&quot;city&quot; = &quot;place&quot;)) Amostras independentes: teste \\(t\\) Digamos que queremos testar se os preços diferem entre cidades grandes e pequenas. Para fazer isso, precisamos de uma variável que indique se um Airbnb está em uma cidade grande ou pequena. Na Bélgica, consideramos cidades com uma população de pelo menos cem mil como grande: airbnb &lt;- airbnb.merged %&gt;% mutate(large = population &gt; 100000, size = factor(large, labels = c(&quot;small&quot;,&quot;large&quot;))) # Nos poderiamos tambem ter escrito: mutate(size = factor(population &gt; 100000, labels = c(&quot;small&quot;,&quot;large))) # observando a variavel populacao head(airbnb$population) ## [1] 231493 1019022 1019022 69011 1019022 1019022 # olhando a maior variavel head(airbnb$large) ## [1] TRUE TRUE TRUE FALSE TRUE TRUE # e o tamanho da variavel head(airbnb$size) ## [1] large large large small large large ## Levels: small large No script acima, primeiro criamos uma variável lógica (esse é outro tipo de variável; discutimos outras aqui). Chamamos essa variável de grande e é TRUE quando a população é maior que 100000 e FALSE, se não. Depois, criamos um novo tamanho de variável que é a fatoração de grande porte. Observe que adicionamos outro argumento à função factor, ou seja, labels, para fornecer os valores large de nomes mais intuitivos. FALSE vem em primeiro lugar no alfabeto e obtém o primeiro rótulo pequeno, TRUE fica em segundo lugar no alfabeto e obtém o segundo rótulo grande. Para saber quais cidades são grandes e quais são pequenas, podemos solicitar frequências de combinações de tamanho (grande versus pequeno) e city (a própria cidade). Aprendemos como fazer isso no capítulo introdutório (consulte as tabelas de frequência e as estatísticas descritivas): airbnb %&gt;% group_by(size, city) %&gt;% summarise(count = n(), population = mean(population)) %&gt;% # Cidades formam os grupos. Portanto, a populacao media de um grupo = a media de observacoes com a mesma populacao, porque elas vem da mesma cidade = a populacao da cidade arrange(desc(size), desc(population)) %&gt;% # maior cidade no topo print (n = Inf) # mostra a distribuicao completa das frequencias ## `summarise()` regrouping output by &#39;size&#39; (override with `.groups` argument) ## # A tibble: 43 x 4 ## # Groups: size [3] ## size city count population ## &lt;fct&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 large Brussel 6715 1019022 ## 2 large Antwerpen 1610 459805 ## 3 large Gent 1206 231493 ## 4 large Charleroi 118 200132 ## 5 large Brugge 1094 116709 ## 6 large Namur 286 106284 ## 7 small Leuven 434 92892 ## 8 small Mons 129 91277 ## 9 small Aalst 74 77534 ## 10 small Mechelen 190 77530 ## 11 small Kortrijk 107 73879 ## 12 small Hasselt 151 69222 ## 13 small Oostende 527 69011 ## 14 small Sint-Niklaas 52 69010 ## 15 small Tournai 97 67721 ## 16 small Roeselare 41 56016 ## 17 small Verviers 631 52824 ## 18 small Moeskroen 28 52069 ## 19 small Dendermonde 45 43055 ## 20 small Turnhout 130 39654 ## 21 small Ieper 143 35089 ## 22 small Tongeren 173 29816 ## 23 small Oudenaarde 110 27935 ## 24 small Ath 47 26681 ## 25 small Arlon 46 26179 ## 26 small Soignies 58 24869 ## 27 small Nivelles 505 24149 ## 28 small Maaseik 93 23684 ## 29 small Huy 99 19973 ## 30 small Tielt 24 19299 ## 31 small Eeklo 43 19116 ## 32 small Marche-en-Famenne 266 16856 ## 33 small Diksmuide 27 15515 ## 34 &lt;NA&gt; Bastogne 145 NA ## 35 &lt;NA&gt; Dinant 286 NA ## 36 &lt;NA&gt; Halle-Vilvoorde 471 NA ## 37 &lt;NA&gt; LiÃ¨ge 667 NA ## 38 &lt;NA&gt; NeufchÃ¢teau 160 NA ## 39 &lt;NA&gt; Philippeville 85 NA ## 40 &lt;NA&gt; Thuin 81 NA ## 41 &lt;NA&gt; Veurne 350 NA ## 42 &lt;NA&gt; Virton 56 NA ## 43 &lt;NA&gt; Waremme 51 NA Vemos que algumas cidades têm um valor de NA para tamanho. Isso ocorre porque não temos população para essas cidades (e, portanto, também não sabemos se é uma cidade grande ou pequena). Vamos filtrar essas observações e verificar as médias e os desvios padrão de preço, dependendo do tamanho da cidade: airbnb.cities &lt;- airbnb %&gt;% filter(!is.na(population)) # Filtre as observacoes para as quais nao temos a populacao. # O ponto de exclamacao deve ser lido como NAO. Entao, queremos manter as observacoes para as quais a populacao NAO eh NA. # Visite https://r4ds.had.co.nz/transform.html#filter-rows-with-filter para conhecer mais sobre operadores logicos (veja secao 5.2.2). airbnb.cities %&gt;% group_by(size) %&gt;% summarise(mean_price = mean(price), sd_price = sd(price), count = n()) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 4 ## size mean_price sd_price count ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 small 110. 122. 4270 ## 2 large 85.8 82.9 11029 Vemos que os preços são mais altos nas pequenas e nas grandes cidades, mas queremos saber se essa diferença é significativa. Um teste t de amostras independentes pode fornecer a resposta (as listagens nas grandes cidades e as listagens nas pequenas cidades são as amostras independentes), mas precisamos verificar primeiro uma suposição: as variâncias das duas amostras independentes são iguais? #install.packages(car) # Para o teste de igualdade de variancias precisaremos do pacote car. library(car) ## Loading required package: carData ## ## Attaching package: &#39;car&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## recode ## The following object is masked from &#39;package:purrr&#39;: ## ## some # Teste de Levene para variancias iguais # Baixo valor p significa que as variancias nao sao iguais. # Primeiro argumento = variavel dependente continua, segundo argumento = variavel independente categorica. leveneTest(airbnb.cities$price, airbnb.cities$size) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 1 134.45 &lt; 2.2e-16 *** ## 15297 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 A hipótese nula de variâncias iguais é rejeitada (\\(p &lt;0,001\\)), portanto, devemos continuar com um teste \\(t\\) que pressupõe variâncias desiguais: # Teste se os preços médios das cidades grandes e pequenas são diferentes. # Indique se o teste deve assumir variações iguais ou não (defina var.equal = TRUE para um teste que assume variações iguais). t.test(airbnb.cities$price ~ airbnb.cities$size, var.equal = FALSE) ## ## Welch Two Sample t-test ## ## data: airbnb.cities$price by airbnb.cities$size ## t = 12.125, df = 5868.3, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 20.55103 28.47774 ## sample estimates: ## mean in group small mean in group large ## 110.31265 85.79826 Você pode relatar o seguinte: “As cidades grandes (M = 85,42, DP = 82,46) tinham um preço mais baixo (\\(t\\) (5762,79) = 12,376, p $&lt;$0,001, variação desigual assumida) do que as cidades pequenas (M = 110,31, DP = 121,63).” ANOVA univariada Quando sua variável independente (categórica) possui apenas dois grupos, é possível testar se as médias da variável dependente (contínua) são significativamente diferentes ou não com um teste \\(t\\). Quando sua variável independente possui mais de dois grupos, você pode testar se as médias são diferentes com uma ANOVA. Por exemplo, digamos que queremos testar se há uma diferença significativa entre os preços médios de casas e apartamentos inteiros, salas privadas e quartos compartilhados. Vamos dar uma olhada nos meios por tipo de quarto: airbnb.summary &lt;- airbnb %&gt;% group_by(room_type) %&gt;% summarise(count = n(), # obtenha as frequencias dos diferentes tipos de quartos mean_price = mean(price), # o preco medio por tipo de quarto sd_price = sd(price)) # e o desvio padrao do preco por tipo de quarto ## `summarise()` ungrouping output (override with `.groups` argument) airbnb.summary ## # A tibble: 3 x 4 ## room_type count mean_price sd_price ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Entire home/apt 11082 113. 118. ## 2 Private room 6416 64.3 46.5 ## 3 Shared room 153 49.6 33.9 Também podemos traçar esses meios em um gráfico de barras: # Ao criar um grafico de barras, o conjunto de dados que serve como entrada para o ggplot eh o resumo com os meios, nao o conjunto de dados completo. # (Eh por isso que salvamos o resumo acima em um objeto airbnb.summary) ggplot(data = airbnb.summary, mapping = aes(x = room_type, y = mean_price)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) Não é de surpreender que casas ou apartamentos inteiros tenham preços mais altos do que quartos particulares, que, por sua vez, têm preços mais altos que quartos compartilhados. Também vemos que há quase o dobro de casas e apartamentos inteiros do que quartos privativos disponíveis e quase não há quartos compartilhados disponíveis. Além disso, o desvio padrão é muito mais alto na categoria de casas ou apartamentos inteiros do que nas categorias de quarto particular ou compartilhado. Uma ANOVA pode testar se há diferenças significativas nos preços médios por tipo de quarto. Porém, antes de executar uma ANOVA, precisamos verificar se as premissas da ANOVA são atendidas. Suposição de normalidade de resíduos A primeira suposição é que a variável dependente (price) é normalmente distribuída em cada nível da variável independente (room_type). Primeiro, vamos inspecionar visualmente se essa suposição será válida: # Ao criar um histograma, o conjunto de dados que serve como entrada para o ggplot eh o conjunto de dados completo, nao o resumo com os meios ggplot(data = airbnb, mapping = aes(x = price)) + # Queremos price no eixo x. facet_wrap(~ room_type) + # Queremos que isso seja dividido por room_type. #facet_wrap garantira que o ggplot crie paineis diferentes no seu gráfico. geom_histogram() # geom_histogram garante que as frequencias dos valores no eixo X sejam plotadas. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pega o melhor valor com `binwidth`. Vemos que há inclinação correta para cada tipo de quarto. Também podemos testar formalmente, dentro de cada tipo de quarto, se as distribuições são normais com o teste Shapiro-Wilk. Por exemplo, para as quartos compartilhados: airbnb.shared &lt;- airbnb %&gt;% filter(room_type == &quot;Shared room&quot;) # reter dados apenas das salas compartilhadas shapiro.test(airbnb.shared$price) ## ## Shapiro-Wilk normality test ## ## data: airbnb.shared$price ## W = 0.83948, p-value = 1.181e-11 O valor-\\(p\\) deste teste é extremamente pequeno, portanto a hipótese nula de que a amostra provém de uma distribuição normal deve ser rejeitada. Se tentarmos o teste Shapiro-Wilk para os quartos privados: airbnb.private &lt;- airbnb %&gt;% filter(room_type == &quot;Private room&quot;) # armazenar dados apenas dos quartos compartilhados #shapiro.test(airbnb.private$price) ## Error in shapiro.test(airbnb.private$price): sample size must be between 3 and 5000 Ocorreu um erro ao dizer que o tamanho da amostra é muito grande. Para contornar esse problema, podemos tentar o teste Anderson-Darling do pacote nortest: #install.packages(&quot;nortest&quot;) library(nortest) ad.test(airbnb.private$price) ## ## Anderson-Darling normality test ## ## data: airbnb.private$price ## A = 372.05, p-value &lt; 2.2e-16 Mais uma vez, rejeitamos a hipótese nula de normalidade. Deixo como exercício para testar a normalidade dos preços de casas e apartamentos inteiros. Agora que sabemos que a suposição de normalidade é violada, o que podemos fazer? Podemos considerar transformar nossa variável dependente com uma transformação de log: ggplot(data=airbnb, mapping=aes(x=log(price, base = exp (1)))) + # Queremos o preco transformado em log no eixo X. facet_wrap(~ room_type) + # Queremos que isso seja dividido por room_type. Facet_wrap garantira que o ggplot crie paineis diferentes no seu grafico. geom_histogram() # geom_histogram garante que as frequencias dos valores no eixo X sejam plotadas. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Como você pode ver, uma transformação de log normaliza uma distribuição inclinada à direita. Poderíamos então executar a ANOVA na variável dependente transformada em log. No entanto, na realidade, muitas vezes é seguro ignorar violações da suposição de normalidade (a menos que você esteja lidando com pequenas amostras, o que nós não somos). Vamos simplesmente continuar com o preço não transformado como variável dependente. Suposição: homogeneidade de variâncias Uma segunda suposição que precisamos verificar é se as variações de nosso preço variável dependente são iguais nas categorias de nossa variável independente room_type. Normalmente, um gráfico boxplot é informativo: ggplot(data = airbnb, mapping = aes(x = room_type, y = price)) + geom_boxplot() Mas, neste caso, os intervalos interquartis (as alturas das caixas), que normalmente nos dariam uma idéia da variação dentro de cada tipo de quarto, são muito estreitos. Isso ocorre porque o intervalo de valores Y a ser plotado é muito amplo devido a alguns valores extremos. Se observarmos os desvios padrão, porém, veremos que estes são muito maiores para todos as salas e apartamentos do que para os quartos privativo e compartilhado: airbnb %&gt;% group_by(room_type) %&gt;% summarise(count = n(), # obtenha as frequencias dos diferentes tipos de quartos mean_price = mean(price), # o preco medio por tipo de quarto sd_price = sd(price)) # e o desvio padrao do preco por tipo de quarto ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 4 ## room_type count mean_price sd_price ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Entire home/apt 11082 113. 118. ## 2 Private room 6416 64.3 46.5 ## 3 Shared room 153 49.6 33.9 Também podemos realizar um teste formal de homogeneidade de variâncias. Para isso, precisamos da função leveneTest do pacote car: #install.packages(&quot;car&quot;) # Para o teste de variancias iguais, precisamos de um pacote chamado car. Instalamos isso antes, portanto, nao eh necessario reinstala-lo se voce ja o tiver feito. library(car) #Teste de Levene de variancias iguais. # Valor baixo de p significa que as variancias nao sao iguais. # Primeiro argumento = variavel dependente continua, segundo argumento = variavel independente categorica. leveneTest(airbnb$price, airbnb$room_type) ## Warning in leveneTest.default(airbnb$price, airbnb$room_type): airbnb$room_type coerced to ## factor. ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 140.07 &lt; 2.2e-16 *** ## 17648 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Como o valor \\(p\\) é extremamente pequeno, rejeitamos a hipótese nula de variâncias iguais. Assim como no pressuposto da normalidade, as violações do pressuposto de variâncias iguais podem, no entanto, ser frequentemente ignoradas e o faremos neste caso. ANOVA Para realizar uma ANOVA, precisamos instalar alguns pacotes: #install.packages(remotes) #O pacote de controles remotos nos permite instalar pacotes armazenados no GitHub, um site para desenvolvedores de pacotes. #install.packages(&quot;car&quot;) #Também precisaremos do pacote do carro para executar a ANOVA (não é necessário reinstalá-lo se você já tiver feito isso). library(remotes) install_github(&#39;samuelfranssens/type3anova&#39;) # Instala o pacote type3anova. Esta e as etapas anteriores precisam ser executadas apenas uma vez. ## Skipping install of &#39;type3anova&#39; from a github remote, the SHA1 (0c38377d) has not changed since last install. ## Use `force = TRUE` to force installation library(type3anova) # Carregue o pacote type3anova. Agora podemos prosseguir com a ANOVA verdadeira: # Primeiro cria um modelo linear # A formula lm() toma os argumentos de dados # A fórmula tem a seguinte sintaxe: variável dependente ~ variável (s) independente linearmodel &lt;- lm(price ~ room_type, data=airbnb) # Em seguida, peça a saída no formato ANOVA. Isso fornece a soma dos quadrados do Tipo III. # Observe que isso é diferente da anova (modelo linear), que fornece a soma dos quadrados do tipo I. type3anova(linearmodel) ## # A tibble: 3 x 6 ## term ss df1 df2 f pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 7618725. 1 17648 803. 0 ## 2 room_type 10120155. 2 17648 534. 0 ## 3 Residuals 167364763. 17648 17648 NA NA Nesse caso, o valor-p associado ao efeito de room_type é praticamente 0, o que significa que rejeitamos a hipótese nula de que o preço médio é igual para cada room_type. Você pode relatar o seguinte: “Houve diferenças significativas entre os preços médios das diferentes tipos de salas (\\(F (2, 17648) = 533,57, p &lt;0,001\\)).” Teste de Tuckey de diferença significativa verdadeira Observe que a ANOVA testa a hipótese nula de que as médias em todos os nossos grupos são iguais. A rejeição desta hipótese nula significa que há uma diferença significativa em pelo menos um dos possíveis pares de médias (ou seja, em casa / apartamento inteiro vs. privado e / ou em casa / apartamento inteiro vs. compartilhado e / ou privado) vs. compartilhado). Para ter uma idéia de qual par de médias contém uma diferença significativa, podemos acompanhar o teste de Tukey, que nos dará todas as comparações pareadas. O teste de Tukey corrige os valores de p para cima - portanto, é mais conservador decidir que algo é significativo - porque as comparações são post-hoc ou exploratórias: TukeyHSD(aov(price ~ room_type, data=airbnb), &quot;room_type&quot;) # O primeiro argumento eh um objeto &quot;aov&quot;, o segundo eh a nossa variavel independente. ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## ## Fit: aov(formula = price ~ room_type, data = airbnb) ## ## $room_type ## diff lwr upr p adj ## Private room-Entire home/apt -49.11516 -52.69593 -45.534395 0.000000 ## Shared room-Entire home/apt -63.79178 -82.37217 -45.211381 0.000000 ## Shared room-Private room -14.67661 -33.34879 3.995562 0.155939 Isso nos mostra que não há diferença significativa no preço médio de quartos compartilhados e privados, mas que quartos compartilhados e quartos particulares diferem significativamente de casas e apartamentos inteiros. "],
["regressão-linear.html", "Regressão Linear Regressão Linear Simples Correlação Regressão linear múltipla, com interação Premissas Normalidade de resíduos Homocedasticidade de resíduos Multicolinearidade Teste \\(\\chi^{2}\\)", " Regressão Linear Regressão Linear Simples Digamos que desejamos prever o preço com base em várias características do quarto. Vamos começar com um caso simples em que prevemos preço com base em um preditor: overal_satisfaction (satisfação geral). A satisfação geral é a classificação que uma listagem recebe no airbnb.com. Vamos fazer um gráfico de dispersão primeiro: ggplot(data = airbnb, mapping = aes(x = overall_satisfaction, y = price)) + geom_jitter() # jitter em vez de pontos, caso contrario, muitos pontos sao desenhados um sobre o outro ## Warning: Removed 7064 rows containing missing values (geom_point). (Recebemos uma mensagem de erro informando que várias linhas foram removidas. Essas são as linhas com valores ausentes para a overall_satisfaction, portanto, não há necessidade de se preocupar com essa mensagem de erro. Consulte as manipulações de dados) para saber por que faltam valores para a overall_satisfaction. Os outliers de preço reduzem a informatividade do gráfico, portanto, vamos transformar a variável price. Também vamos adicionar alguns meios ao gráfico, como aprendemos aqui, e uma linha de regressão: ggplot(data = airbnb, mapping = aes(x = overall_satisfaction, y = log(price, base = exp(1)))) + geom_jitter() + # jitter em vez de pontos, caso contrario, muitos pontos sao desenhados um sobre o outro stat_summary(fun.y=mean, colour=&quot;green&quot;, size = 4, geom=&quot;point&quot;, shape = 23, fill = &quot;green&quot;) + # medias stat_smooth(method = &quot;lm&quot;, se=FALSE) # reta de regressao ## Warning: `fun.y` is deprecated. Use `fun` instead. ## Warning: Removed 7064 rows containing non-finite values (stat_summary). ## `geom_smooth()` using formula &#39;y ~ x&#39; ## Warning: Removed 7064 rows containing non-finite values (stat_smooth). ## Warning: Removed 7064 rows containing missing values (geom_point). Vemos que o preço tende a aumentar um pouco com maior satisfação. Para testar se a relação entre preço e satisfação é realmente significativa, podemos realizar uma regressão simples (simples refere-se ao fato de haver apenas um preditor): linearmodel &lt;- lm(price ~ overall_satisfaction, data = airbnb) # criamos um modelo linear. O primeiro argumento eh o modelo que assume a forma de variavel dependente - variavel (s) independente (s). O segundo argumento sao os dados que devemos considerar. summary(linearmodel) # solicite um resumo dos resultados desse modelo linear ## ## Call: ## lm(formula = price ~ overall_satisfaction, data = airbnb) ## ## Residuals: ## Min 1Q Median 3Q Max ## -80.51 -38.33 -15.51 14.49 1564.67 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 29.747 8.706 3.417 0.000636 *** ## overall_satisfaction 12.353 1.864 6.626 3.62e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 71.47 on 10585 degrees of freedom ## (7064 observations deleted due to missingness) ## Multiple R-squared: 0.00413, Adjusted R-squared: 0.004036 ## F-statistic: 43.9 on 1 and 10585 DF, p-value: 3.619e-11 Vemos dois parâmetros neste modelo: \\(\\beta_{0}\\) ou intercepto (29.75) \\(\\beta_{1}\\) inclinação de overral_satisfaction (12.35) Esses parâmetros têm as seguintes interpretações. A interceptação (\\(\\beta_{0}\\)) é o preço estimado para uma observação com satisfação geral igual a zero. A inclinação (\\(\\beta_{1}\\)) é o aumento estimado do preço para cada aumento na satisfação geral. Isso determina a inclinação da linha de regressão ajustada no gráfico. Portanto, para uma listagem com uma satisfação geral de, por exemplo, 3,5, o preço estimado é 29,75 + 3,5× 12,35 = 72,98. A inclinação é positiva e significativa. Você pode relatar o seguinte: “Havia uma relação significativamente positiva entre preço e satisfação geral (\\(\\beta = 12,35\\), t (10585) = 6,63, $p &lt;$0,001).” Na saída, também obtemos informações sobre o modelo geral. O modelo vem com um valor F de 43,9 com 1 grau de liberdade no numerador e 10585 graus de liberdade no denominador. Essa estatística F nos diz se nosso modelo com um preditor (overall_satisfaction) prediz a variável dependente (price) melhor do que um modelo sem preditores (o que simplesmente preveria a média do preço para todos os níveis de satisfação geral). Os graus de liberdade nos permitem encontrar o valor \\(p\\) correspondente ($&lt;$0,001) da estatística F (43,9). Os graus de liberdade no numerador são iguais ao número de preditores em nosso modelo. Os graus de liberdade no denominador são iguais ao número de observações menos o número de preditores menos um. Lembre-se de que temos 10587 observações para as quais temos valores para price e overall_satisfaction. Como o valor \\(p\\) é menor que 0,05, rejeitamos a hipótese nula de que nosso modelo não prediz melhor a variável dependente do que um modelo sem preditores. Observe que, no caso de regressão linear simples, o valor p do modelo corresponde ao valor \\(p\\) do preditor único. Para modelos com mais preditores, não existe essa correspondência. Por fim, observe também a estatística do R quadrado do modelo. Esta estatística é igual a 0,004. Essa estatística nos diz quanto da variação na variável dependente é explicada por nossos preditores. Quanto mais preditores você adicionar a um modelo, maior será o R quadrado. Correlação Observe que na regressão linear simples, a inclinação do preditor é uma função da correlação entre o preditor e a variável dependente. Podemos calcular a correlação da seguinte maneira: # Certifique-se de incluir o argumento use, caso contrario, o resultado sera NA devido aos valores ausentes na overall_satisfaction. # O argumento use instrui o R para calcular a correlacao com base apenas nas observacoes para as quais temos dados sobre price e overall_satisfaction. cor(airbnb$price, airbnb$overall_satisfaction, use = &quot;pairwise.complete.obs&quot;) ## [1] 0.06426892 Vemos que a correlação é positiva, mas muito baixa (r = 0,064). Elevando ao quadrado essa correlação, você obterá o R quadrado de um modelo com apenas esse preditor (0,064 × 0,064 = 0,004). Ao lidar com múltiplos preditores (como na próxima seção), podemos gerar uma matriz de correlação. Isso é especialmente útil ao verificar a multicolinearidade. Digamos que desejamos que as correlações entre, price, overall_satisfaction, reviews, accommodates: airbnb.corr &lt;- airbnb%&gt;% filter(! is.na (overall_satisfaction))%&gt;% # caso contrario, você vera NAs no resultado select(price, overall_satisfaction, reviews, accommodates) cor(airbnb.corr) # obter a matriz de correlacao ## price overall_satisfaction reviews accommodates ## price 1.00000000 0.06426892 -0.05827489 0.63409855 ## overall_satisfaction 0.06426892 1.00000000 0.03229339 -0.04698709 ## reviews -0.05827489 0.03229339 1.00000000 -0.03862767 ## accommodates 0.63409855 -0.04698709 -0.03862767 1.00000000 cor(airbnb.corr) # obtenha a matriz de correlacao ## price overall_satisfaction reviews accommodates ## price 1.00000000 0.06426892 -0.05827489 0.63409855 ## overall_satisfaction 0.06426892 1.00000000 0.03229339 -0.04698709 ## reviews -0.05827489 0.03229339 1.00000000 -0.03862767 ## accommodates 0.63409855 -0.04698709 -0.03862767 1.00000000 Você pode visualizar facilmente essa matriz de correlação: #install.packages(corrplot) # instala e carrega o pacote corrplot library(corrplot) ## corrplot 0.84 loaded corrplot(cor(airbnb.corr), method = &quot;number&quot;, type = &quot;lower&quot;, bg = &quot;grey&quot;) # apresente numa tabela As cores das correlações dependem de seus valores absolutos. Você também pode obter valores de p para as correlações (\\(p &lt;0,05\\) indica que a correlação difere significativamente de zero): # O comando para os valores-p eh cor.mtest(airbnb.corr) # Mas queremos apenas os valores-p, portanto $ p # E arredondamos para cinco digitos, portanto arredondamos (, 5) round(cor.mtest(airbnb.corr)$p, 5) ## [,1] [,2] [,3] [,4] ## [1,] 0 0.00000 0.00000 0e+00 ## [2,] 0 0.00000 0.00089 0e+00 ## [3,] 0 0.00089 0.00000 7e-05 ## [4,] 0 0.00000 0.00007 0e+00 Regressão linear múltipla, com interação Frequentemente, estamos interessados em interações entre preditores (por exemplo, overall_satisfaction e reviews). Uma interação entre preditores nos diz que o efeito de um preditor depende do nível do outro preditor: # overall_satisfaction + reviews: a interacao nao eh incluida como preditor # overall_satisfaction * reviews: a interacao entre os dois preditores eh incluida como preditora summary(lm(formula = price ~ overall_satisfaction * reviews, data = airbnb)) ## ## Call: ## lm(formula = price ~ overall_satisfaction * reviews, data = airbnb) ## ## Residuals: ## Min 1Q Median 3Q Max ## -82.17 -36.71 -16.08 13.47 1561.53 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 48.77336 10.14434 4.808 1.55e-06 *** ## overall_satisfaction 8.91437 2.17246 4.103 4.10e-05 *** ## reviews -0.99200 0.26160 -3.792 0.00015 *** ## overall_satisfaction:reviews 0.18961 0.05573 3.402 0.00067 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 71.31 on 10583 degrees of freedom ## (7064 observations deleted due to missingness) ## Multiple R-squared: 0.008861, Adjusted R-squared: 0.00858 ## F-statistic: 31.54 on 3 and 10583 DF, p-value: &lt; 2.2e-16 Com esse modelo, preço estimado = \\(\\beta_{0} + \\beta_{1}\\mbox{\\textit{overall\\_satisfaction}} + \\beta_{2}reviews + \\beta_{3}\\mbox{\\textit{overall\\_satisfaction}} × reviews\\), em que: \\(\\beta_{0}\\) é o intercepto (48.77) controlando todas as outras variáveis em nosso modelo \\(\\beta_{2}\\) representa a relação entre revisões e preço (-0.99), controlando todas as outras variáveis em nosso modelo \\(\\beta_{3}\\) é a interação entre satisfação geral e revisões (0.19) Para um determinado nível de reviews, o relacionamento entre overall_satisfaction e price pode ser reescrito como: \\[ =[\\beta_{0}+\\beta_{2}\\mbox{reviews}]+(\\beta_{1}+\\beta_{3}\\mbox{reviews})\\times\\,\\,\\mbox{overall_satisfaction} \\] Vemos que tanto a interceptação (\\(\\beta_{0}+\\beta_{2}reviews\\)) e a inclinação (\\(\\beta_{1}+\\beta_{3}reviews\\)) a relação entre overall_satisfaction} e price} depende de reviews}. No modelo sem interações, apenas a interceptação da relação entre overall_satisfaction e price dependia de reviews. Como adicionamos ao nosso modelo uma interação entre a overall_satisfaction e o reviews, a inclinação agora também depende de reviews. Da mesma forma, para um determinado nível de overall_satisfaction, o relacionamento entre reviews e price pode ser reescrito como: \\[ =[\\beta_{0}+\\beta_{1}\\mbox{overall_satisfaction}]+(\\beta_{2}+\\beta_{3}\\mbox{overall_satisfaction})\\times\\,\\,\\mbox{reviews} \\] Aqui também vemos que tanto a interceptação quanto a inclinação da relação entre revisões (reviews) e preço (price) dependem da satisfação geral (overall_satisfaction). Como dito, quando o relacionamento entre uma variável independente e uma variável dependente depende do nível de outra variável independente, temos uma interação entre as duas variáveis independentes. Para esses dados, a interação é altamente significativa (\\(p &lt;0,001\\)). Vamos visualizar essa interação. Nós nos concentramos na relação entre satisfação geral e preço. Planejaremos isso para um nível de comentários que possa ser considerado baixo, médio e alto: airbnb %&gt;% filter(!is.na(overall_satisfaction)) %&gt;% summarise(min = min(reviews), Q1 = quantile(reviews, .25), # primeiro quartil Q2 = quantile(reviews, .50), # segundo quartil ou mediana Q3 = quantile(reviews, .75), # terceiro quartil max = max(reviews), mean = mean(reviews)) ## min Q1 Q2 Q3 max mean ## 1 3 6 13 32 708 28.47955 e crie grupos com base nesses números: airbnb.reviews &lt;- airbnb %&gt;% filter(!is.na(overall_satisfaction)) %&gt;% mutate(review_group = case_when(reviews &lt;= quantile(reviews, .33) ~ &quot;low&quot;, reviews &lt;= quantile(reviews, .66) ~ &quot;medium&quot;, TRUE ~ &quot;high&quot;), review_group = factor(review_group, levels = c(&quot;low&quot;,&quot;medium&quot;,&quot;high&quot;))) Por isso, pedimos ao R para criar uma nova variável review_group que deve ser igual a “low” quando o número de revisões for menor ou igual ao 33º percentil, “medium” quando o número de revisões for menor ou igual ao 66º percentil e “high”, caso contrário. Depois, fatoramos a variável review_group recém-criada e fornecemos um novo argumento, levels, que especifica a ordem dos níveis dos fatores (caso contrário, a ordem seria alfabética: alta, baixa, média). Vamos verificar se o agrupamento foi bem-sucedido: # checagem: airbnb.reviews %&gt;% group_by(review_group) %&gt;% summarise(min = min(reviews), max = max(reviews)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 3 ## review_group min max ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 low 3 8 ## 2 medium 9 23 ## 3 high 24 708 De fato, o número máximo de revisões em cada grupo corresponde aos pontos de corte definidos acima. Agora, podemos solicitar a R um gráfico da relação entre overall_satisfaction e price para os três níveis de revisão: ggplot(data = airbnb.reviews, mapping = aes(x = overall_satisfaction, y = log(price, base = exp(1)))) + # transformacao log de preco facet_wrap(~ review_group) + # peca paineis diferentes para cada grupo de revisao geom_jitter() + stat_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; Vemos que a relação entre overall_satisfaction e price é sempre positiva, mas é mais positiva para listagens com muitas críticas do que para listagens com poucas críticas. Pode haver muitas razões para isso. Talvez seja o caso de listagens com críticas positivas aumentarem o preço, mas somente depois de receberem uma certa quantidade de críticas. Também vemos que as listagens com muitas avaliações quase nunca têm uma classificação de satisfação menor que 3. Isso faz sentido, porque é difícil continuar atraindo pessoas quando a classificação de uma listagem é baixa. Listas com poucas críticas tendem a ter baixos índices de satisfação geral. Portanto, parece que nossos preditores estão correlacionados: quanto mais avaliações uma listagem tiver, maior será seu índice de satisfação. Isso potencialmente apresenta um problema que discutiremos em uma das próximas seções sobre multicolinearidade Premissas Antes de tirar conclusões de uma análise de regressão, é preciso verificar várias suposições. Essas premissas devem ser atendidas independentemente do número de preditores no modelo, mas continuaremos com o caso de dois preditores. Normalidade de resíduos Os resíduos (a diferença entre os valores observados e os estimados) devem ser normalmente distribuídos. Podemos inspecionar visualmente os resíduos: linearmodel &lt;- lm(price ~ overall_satisfaction * reviews, data = airbnb) residuals &lt;- as_tibble(resid(linearmodel)) #Atenção: Chamar `as_tibble ()` em um vetor eh desencorajado, porque eh provavel que o comportamento mude no futuro. Use `enframe (name = NULL)` em seu lugar. ## Este aviso eh exibido uma vez por sessao. # veja os residuos do modelo linear com resid(linearmodel) # e mude isso em seu dataframe com as_tibble() ggplot(data = residuals, mapping = aes(x = value)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Homocedasticidade de resíduos Os resíduos (a diferença entre os valores observados e os estimados) devem ter uma variação constante. Podemos verificar isso plotando os resíduos versus os valores previstos: linearmodel &lt;- lm(price ~ overall_satisfaction * reviews, data = airbnb) # cria um dataframe (a tibble) residuals_predicted &lt;- tibble(residuals = resid(linearmodel), # a primeira variavel são residuos, que sao os residuos do nosso modelo linear predicted = predict(linearmodel)) # a segunda variavel eh prevista, quais sao os valores previstos do nosso modelo linear ggplot(data = residuals_predicted, mapping = aes(x = predicted, y = residuals)) + geom_point() Essa suposição é violada porque, quanto maiores nossos valores previstos, maior a variação que vemos nos resíduos. Multicolinearidade A multicolinearidade existe sempre que dois ou mais dos preditores em um modelo de regressão são moderadamente ou altamente correlacionados (portanto, é claro que isso não é um problema no caso de regressão simples). Vamos testar a correlação entre overall_satisfaction e reviews: # Certifique-se de incluir o argumento use, caso contrario, o resultado sera NA devido aos valores ausentes no overall_satisfaction. # O argumento use instrui o R para calcular a correlacao com base apenas nas observacoes para as quais temos dados sobre price e overall_satisfaction. cor.test(airbnb$overall_satisfaction,airbnb$reviews, use = &quot;pairwise.complete.obs&quot;) # teste para correlacao ## ## Pearson&#39;s product-moment correlation ## ## data: airbnb$overall_satisfaction and airbnb$reviews ## t = 3.3242, df = 10585, p-value = 0.0008898 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.01325261 0.05131076 ## sample estimates: ## cor ## 0.03229339 Nossos preditores são de fato significativamente correlacionados ($p &lt;$0,001), mas a correlação é realmente baixa (0,03). Ao lidar com mais de dois preditores, é uma boa idéia criar uma matriz de correlação. O problema da multicolinearidade é que ela infla os erros padrão dos coeficientes de regressão. Como resultado, os testes de significância desses coeficientes terão mais dificuldade em rejeitar a hipótese nula. Podemos facilmente ter uma idéia do grau em que os coeficientes são inflados. Para ilustrar isso, vamos estimar um modelo com preditores correlacionados: acomodações (accommodates) e preço (price) (\\(r = 0,56\\)). linearmodel &lt;- lm(overall_satisfaction ~ accommodates * price, data = airbnb) summary(linearmodel) ## ## Call: ## lm(formula = overall_satisfaction ~ accommodates * price, data = airbnb) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.6494 -0.1624 -0.1105 0.3363 0.6022 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.622e+00 9.938e-03 465.031 &lt; 2e-16 *** ## accommodates -1.640e-02 2.039e-03 -8.046 9.48e-16 *** ## price 1.356e-03 1.159e-04 11.702 &lt; 2e-16 *** ## accommodates:price -5.423e-05 9.694e-06 -5.595 2.26e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3689 on 10583 degrees of freedom ## (7064 observations deleted due to missingness) ## Multiple R-squared: 0.0199, Adjusted R-squared: 0.01963 ## F-statistic: 71.64 on 3 and 10583 DF, p-value: &lt; 2.2e-16 Vemos que todos os preditores são significativos. Vamos dar uma olhada nos fatores de inflação da variância: library(car) # a funcao vif eh do pacote cars vif(linearmodel) ## accommodates price accommodates:price ## 2.090206 5.359203 6.678312 Os fatores VIF informam até que ponto os erros padrão são inflados. Uma regra prática é que VIFs de 5 e acima indicam inflação significativa. Teste \\(\\chi^{2}\\) Suponha que tenhamos interesse em encontrar uma verdadeira jóia (gem) de uma lista. Por exemplo, estamos interessados em listagens com uma classificação de 5 em 5 e pelo menos 30 avaliações: airbnb &lt;- airbnb %&gt;% mutate(gem = (overall_satisfaction == 5 &amp; reviews&gt;=30), # duas condicoes devem ser atendidas antes de dizer que uma listagem eh uma joia gem = factor(gem, labels = c(&quot;no gem&quot;,&quot;gem&quot;))) # de a variavel logica rotulos mais intuitivos Agora, digamos que estamos interessados em saber se é mais provável encontrar “jóias” (gem) em cidades pequenas ou grandes (criamos a variável de tamanho aqui). O teste do qui-quadrado pode fornecer uma resposta a essa pergunta testando a hipótese nula de não haver relação entre duas variáveis categóricas (tamanho da cidade: large vs. small &amp; gem: yes vs. no). Ele compara a tabela de frequências observada com a tabela de frequências que você esperaria quando não houvesse relação entre as duas variáveis. Quanto mais as tabelas de frequência observada e esperada divergem, maior a estatística qui-quadrado, menor o valor de p e menos provável é que as duas variáveis não sejam relacionadas. Antes de realizarmos um teste qui-quadrado, lembre-se de que algumas cidades têm um valor em falta para o tamanho porque têm um valor em falta para a population. Vamos filtrar isso primeiro: airbnb.cities &lt;- airbnb %&gt;% filter(!is.na(size)) # queremos apenas aquelas observacoes em que tamanho nao eh NA. ! significa &#39;nao&#39; # veja https://r4ds.had.co.nz/transform.html#filter-rows-with-filter para mais funcoes logicas (desca ate a secao 5.2.2) Agora, imprima as frequências do tamanho da cidade e combinações de gems: airbnb.cities %&gt;% group_by(size, gem) %&gt;% summarise(count = n()) ## `summarise()` regrouping output by &#39;size&#39; (override with `.groups` argument) ## # A tibble: 4 x 3 ## # Groups: size [2] ## size gem count ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 small no gem 4095 ## 2 small gem 175 ## 3 large no gem 10117 ## 4 large gem 912 Esta informação está correta, mas o formato em que a tabela é apresentada é um pouco incomum. Gostaríamos de ter uma variável como linhas e a outra como colunas: table(airbnb.cities$size, airbnb.cities$gem) ## ## no gem gem ## small 4095 175 ## large 10117 912 Isso é um pouco mais fácil de interpretar. Uma tabela como essa é frequentemente chamada de tabela cruzada. É fácil pedir porcentagens em vez de contagens: crosstable &lt;- table(airbnb.cities$size, airbnb.cities$gem) #Precisamos salvar a tabela cruzada primeiro. prop.table(crosstable) # Use a funcao prop.table () para solicitar porcentagens. ## ## no gem gem ## small 0.26766455 0.01143866 ## large 0.66128505 0.05961174 Com base nessas frequências ou porcentagens, não devemos esperar uma forte relação entre size e gem. Vamos realizar o teste do qui-quadrado para testar nossa intuição: chisq.test(crosstable) ## ## Pearson&#39;s Chi-squared test with Yates&#39; continuity correction ## ## data: crosstable ## X-squared = 80.497, df = 1, p-value &lt; 2.2e-16 O valor da estatística qui é 74,35 e o valor p é praticamente 0, por isso rejeitamos a hipótese nula de nenhum relacionamento. Não é o que esperávamos, mas o valor p é baixo porque nossa amostra é bastante grande (15966 observações). Você pode relatar o seguinte: “Havia uma relação significativa entre o tamanho da cidade e se uma listagem era ou não uma jóia (\\(\\chi^{2} (1, N = 15966) = 74,35, p &lt;0,001\\)), de modo que as cidades grandes (8,05%) tinham uma porcentagem maior de jóias (raridades) do que as cidades pequenas (4,1%). "],
["regressão-logística-opcional.html", "Regressão Logística (opcional) Medindo o ajuste de uma regressão logística: porcentagem classificada corretamente", " Regressão Logística (opcional) Às vezes, queremos prever uma variável dependente binária, ou seja, uma variável que pode assumir apenas dois valores, com base em várias variáveis independentes contínuas ou categóricas. Por exemplo, digamos que estamos interessados em testar se uma listagem é ou não uma jóia depende do preço e do tipo de quarto da listagem. Não podemos usar ANOVA ou regressão linear aqui porque a variável dependente é uma variável binária e, portanto, normalmente não é distribuída. Outro problema com a ANOVA ou regressão linear é que ela pode prever valores que não são possíveis (por exemplo, nosso valor previsto pode ser 5, mas apenas 0 e 1 fazem sentido para essa variável dependente). Portanto, usaremos regressão logística. A regressão logística primeiro transforma a variável dependente Y com a transformação do logit. A transformação do logit usa o logaritmo natural das chances de que a variável dependente seja igual a 1: \\[ probabilidades=\\displaystyle\\frac{P(Y=1)}{P(Y=0}=\\displaystyle\\frac{P(Y=1)}{1-P(Y=1)} \\] então o logit \\(P(Y=1))=\\ln\\displaystyle\\frac{P(Y-1)}{1-P(Y=1)}\\) Isso garante que nossa variável dependente seja normalmente distribuída e não seja restrita a ser 0 ou 1.Isso garante que nossa variável dependente seja normalmente distribuída e não seja restrita a ser 0 ou 1. Vamos realizar a regressão logística: logistic.model &lt;- glm(gem ~ price * room_type, data=airbnb, family=&quot;binomial&quot;) # o argumento family = &quot;binomial&quot; diz R para tratar a variavel dependente como uma variavel 0/1 summary(logistic.model) # saida da regressao ## ## Call: ## glm(formula = gem ~ price * room_type, family = &quot;binomial&quot;, data = airbnb) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.4909 -0.3819 -0.3756 -0.3660 2.5307 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -2.5270702 0.0570207 -44.318 &lt;2e-16 *** ## price -0.0007185 0.0004030 -1.783 0.0746 . ## room_typePrivate room -0.0334362 0.1072091 -0.312 0.7551 ## room_typeShared room 1.0986318 1.1278159 0.974 0.3300 ## price:room_typePrivate room -0.0011336 0.0012941 -0.876 0.3810 ## price:room_typeShared room -0.0562610 0.0381846 -1.473 0.1406 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 8663.8 on 17650 degrees of freedom ## Residual deviance: 8648.6 on 17645 degrees of freedom ## AIC: 8660.6 ## ## Number of Fisher Scoring iterations: 7 Vemos que o único preditor marginalmente significativo de uma listagem ser ou não uma jóia é o preço da listagem. Você pode relatar o seguinte: “Controlando o tipo de quarto e a interação entre preço e tipo de quarto, havia uma relação negativa marginalmente significativa entre o preço e a probabilidade de uma listagem ser uma jóia (\\(\\beta\\) = -0.0007185, \\(\\chi\\) (17645) = -1,783, p = 0,075). A interpretação dos coeficientes de regressão na regressão logística é diferente da do caso da regressão linear: summary(logistic.model) ## ## Call: ## glm(formula = gem ~ price * room_type, family = &quot;binomial&quot;, data = airbnb) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.4909 -0.3819 -0.3756 -0.3660 2.5307 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -2.5270702 0.0570207 -44.318 &lt;2e-16 *** ## price -0.0007185 0.0004030 -1.783 0.0746 . ## room_typePrivate room -0.0334362 0.1072091 -0.312 0.7551 ## room_typeShared room 1.0986318 1.1278159 0.974 0.3300 ## price:room_typePrivate room -0.0011336 0.0012941 -0.876 0.3810 ## price:room_typeShared room -0.0562610 0.0381846 -1.473 0.1406 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 8663.8 on 17650 degrees of freedom ## Residual deviance: 8648.6 on 17645 degrees of freedom ## AIC: 8660.6 ## ## Number of Fisher Scoring iterations: 7 O coeficiente de regressão do preço é -0.0007185. Isso significa que um aumento de uma unidade no preço levará a um aumento de -0.0007185 nas chances de log de joia ser igual a 1 (ou seja, de uma listagem sendo uma joia). Por exemplo: \\[ \\textrm{logit}(P(Y = 1 | \\textrm{price} = 60 )) = \\textrm{logit}(P(Y = 1 | \\textrm{price} = 59 )) - 0.0007185 \\] \\[ \\mbox{logit}(P(Y = 1 | \\mbox{price} = 60 )) = \\mbox{logit}(P(Y = 1 | \\mbox{price} = 59 )) - 0.0007185 \\] \\[ \\Leftrightarrow \\textrm{logit}(P(Y = 1 | \\textrm{price} = 60 )) - \\textrm{logit}(P(Y = 1 | \\textrm{price} = 59 )) = -0.0007185 \\] \\[ \\Leftrightarrow \\textrm{ln(probs}(P(Y = 1 | \\textrm{price} = 60 )) - \\textrm{ln(probs}(P(Y = 1 | \\textrm{price} = 59 )) = -0.0007185 \\] \\[ \\Leftrightarrow \\textrm{ln}(\\dfrac{ \\textrm{probs}(P(Y = 1 | \\textrm{price} = 60 )}{\\textrm{probs}(P(Y = 1 | \\textrm{price} = 59 )}) = -0.0007185 \\] \\[ \\Leftrightarrow \\dfrac{ \\textrm{probs}(P(Y = 1 | \\textrm{price} = 60 )}{\\textrm{probs}(P(Y = 1 | \\textrm{price} = 59 )} = e^{-0.0007185} \\] \\[ \\Leftrightarrow \\textrm{probs}(P(Y = 1 | \\textrm{price} = 60 ) = e^{-0.0007185} * \\textrm{probs}(P(Y = 1 | \\textrm{price} = 59 ) \\] Assim, o coeficiente de regressão em uma regressão logística deve ser interpretado como o aumento relativo nas chances da variável dependente ser igual a 1, para cada aumento de unidade no preditor, controlando todos os outros fatores em nosso modelo. Nesse caso, as probabilidades de uma listagem ser uma gema devem ser multiplicadas por $ e ^ {0,0007185} = 0,999 $ ou diminuídas em 0,1%, para cada aumento de preço unitário. Em outras palavras, listagens mais caras têm menos probabilidade de serem jóias. No exemplo específico acima, as chances de ser uma joia de uma listagem com preço de 60 são \\(e^{(-0.0007185×5)}= 0,996\\) vezes a chance de ser uma jóia de uma listagem com preço de 59. Medindo o ajuste de uma regressão logística: porcentagem classificada corretamente Nosso modelo usa o preço e o tipo de quarto da listagem para prever se a listagem é uma joia ou não. Ao fazer previsões, é natural nos perguntarmos se nossas previsões são boas. Em outras palavras, usando preço e tipo de quarto, com que frequência prevemos corretamente se uma listagem é uma jóia ou não? Para ter uma idéia da qualidade de nossas previsões, podemos pegar o preço e o tipo de quarto das listagens em nosso conjunto de dados, prever se as listagens são gemas e comparar nossas previsões com o status real da gema das listagens. Vamos primeiro fazer as previsões: airbnb &lt;- airbnb %&gt;% mutate(prediction = predict(logistic.model, airbnb)) # Crie uma nova coluna chamada previsao no quadro de dados do airbnb e armazene nela a previsao, # baseado em logistic.model, para os dados do airbnb # De uma olhada nessas previsoes: head(airbnb$prediction) ## 1 2 3 4 5 6 ## -4.790232 -4.448355 -4.049498 -4.619293 -4.106477 -4.847211 # Compare com as observacoes: head(airbnb$gem) ## [1] no gem no gem no gem no gem no gem no gem ## Levels: no gem gem Você vê o problema? As previsões são logits, ou seja, logaritmos de chances de que as listagens sejam gemas, mas as observações simplesmente nos dizem se uma listagem é uma gema ou não. Para uma comparação significativa entre previsões e observações, precisamos transformar os logits em uma decisão: gema ou não gema. É fácil transformar logits em probabilidades usando o exponencial do logit. A relação entre probabilidades e probabilidades é a seguinte: \\[ \\textrm{probs} = \\dfrac{P(Y = 1)}{P(Y = 0)} = \\dfrac{P(Y = 1)}{1 - P(Y = 1)} \\] \\[ \\Leftrightarrow \\dfrac{probs}{1 + \\dfrac{P(Y = 1)}{1 - P(Y = 1)}} = \\dfrac{\\dfrac{P(Y = 1)}{1 - P(Y = 1)}}{1 + \\dfrac{P(Y = 1)}{1 - P(Y = 1)}} \\] \\[ \\Leftrightarrow \\dfrac{probs}{1 + probs} = \\dfrac{\\dfrac{P(Y = 1)}{1 - P(Y = 1)}}{\\dfrac{1 - P(Y = 1) + P(Y = 1)}{1 - P(Y = 1)}} \\] \\[ \\Leftrightarrow \\dfrac{probs}{1 + probs} = \\dfrac{P(Y = 1)}{1 - P(Y = 1) + P(Y = 1)} \\] \\[ \\Leftrightarrow \\dfrac{probs}{1 + probs} = P(Y = 1) \\] Agora vamos calcular, para cada listagem, a probabilidade de a listagem ser uma jóia (gem): airbnb &lt;- airbnb %&gt;% mutate(prediction.logit = predict(logistic.model, airbnb), prediction.odds = exp(prediction.logit), prediction.probability = prediction.odds / (1+prediction.odds)) # Inspecionando as probabilidades preditas head(airbnb$prediction.probability) ## 1 2 3 4 5 6 ## 0.008242034 0.011562542 0.017132489 0.009763496 0.016198950 0.007789092 Os primeiros números são probabilidades muito baixas, mas também existem probabilidades mais altas e todas as previsões estão entre 0 e 1, como deveriam. Agora precisamos decidir qual probabilidade é suficiente para prevermos que uma listagem é uma gem ou não. Uma escolha óbvia é uma probabilidade de 0,5: uma probabilidade maior que 0,5 significa que prevemos que é mais provável que uma listagem seja uma gem do que não. Vamos converter probabilidades em previsões: airbnb &lt;- airbnb %&gt;% mutate(prediction = case_when(prediction.probability&lt;=.50 ~ &quot;no gem&quot;, prediction.probability&gt; .50 ~ &quot;gem&quot;)) # Inspecinando as predicoes head(airbnb$prediction) ## [1] &quot;no gem&quot; &quot;no gem&quot; &quot;no gem&quot; &quot;no gem&quot; &quot;no gem&quot; &quot;no gem&quot; Uma etapa final é comparar previsões com observações: table(airbnb$prediction, airbnb$gem) ## ## no gem gem ## no gem 16471 1180 Normalmente, vemos uma tabela 2x2, mas vemos uma tabela com um valor previsto nas linhas e dois valores observados nas colunas. Isso ocorre porque todas as probabilidades previstas estão abaixo de 0,50 e, portanto, sempre previmos que não há gemas. Vamos reduzir o limite para prever que uma listagem é uma gem: airbnb &lt;- airbnb %&gt;% mutate(prediction = case_when(prediction.probability&lt;=.07 ~ &quot;no gem&quot;, prediction.probability&gt; .07 ~ &quot;gem&quot;), prediction = factor(prediction, levels = c(&quot;no gem&quot;,&quot;gem&quot;)))# verifique se nenhuma joia eh o primeiro nivel do nosso fator # Observando a tabela table(airbnb$prediction,airbnb$gem) ## ## no gem gem ## no gem 11240 854 ## gem 5231 326 Podemos ver que, com esta regra de decisão (prever gems sempre que a probabilidade prevista de gems for superior a 7%), obtivemos 11240 + 326 corretas e 5231 + 854 previsões erradas, que é uma taxa de acerto de (11240 + 326) / (11240 + 326 + 5231 + 854) = 65,5%. "],
["análise-básica-de-dados-experimentos.html", "Análise Básica de Dados: Experimentos Dados Teste \\(t\\) Análise de moderação: interação entre variáveis independentes contínuas e categóricas Análise ANCOVA Medidas repetidas ANOVA", " Análise Básica de Dados: Experimentos Neste capítulo, analisaremos os dados de um experimento que testou se o senso de poder das pessoas afeta sua disposição de pagar (WTP) por produtos relacionados ao status (ou seja, por consumo conspícuo) e se essa relação é diferente quando a WTP desses produtos é visível para os outros versus não. Os participantes vieram ao nosso laboratório em grupos de oito ou sete. Estavam sentados em frente a um computador em cubículos semi-fechados. Na introdução, os participantes leram que primeiro teriam que preencher um questionário de personalidade e uma pesquisa sobre como eles lidavam com dinheiro. Depois disso, eles teriam que trabalhar juntos em grupos de dois em alguns quebra-cabeças. A primeira parte da sessão foi um questionário de personalidade avaliando dominância e aspirações de status (Cassidy &amp; Lynn, 1989; Mead &amp; Maner, 2012). Os participantes leram 18 declarações e indicaram se cada uma delas se aplicava a elas ou não. Após o preenchimento deste questionário, os participantes foram lembrados de que, no final da sessão, teriam que trabalhar juntos com outro participante em alguns quebra-cabeças. Cada díade consistiria em um gerente e um trabalhador. Os participantes leram que a atribuição a esses papéis foi baseada em seus resultados no questionário de personalidade, mas, na realidade, a atribuição a papéis foi aleatória. Os participantes na condição de alta potência então leram que eram mais adequados para serem gerentes, enquanto os participantes na condição de baixa potência liam que eram mais adequados para serem trabalhadores (Galinsky, Gruenfeld e Magee, 2003). As instruções deixaram claro que os gerentes teriam mais poder na tarefa de resolver quebra-cabeças do que os trabalhadores (eles poderiam decidir como um bônus em potencial de 20 euros seria dividido entre gerente e trabalhador). Antes de iniciar os quebra-cabeças, no entanto, os participantes foram convidados a participar de um estudo diferente. Em um estudo ostensivamente diferente, a disposição dos participantes de gastar em produtos conspícuos e discretos foi medida. Na introdução desta parte do experimento, a presença do público foi manipulada. Na condição privada, os participantes foram informados simplesmente de que estávamos interessados em seus padrões de consumo. Eles foram questionados quanto gastariam em dez produtos que diferiam na medida em que poderiam ser usados para sinalizar o status. Os produtos conspícuos ou aprimoradores de status eram: um carro novo, uma casa, viagens, roupas e um relógio de pulso (para homens) ou jóias (para mulheres). Os produtos discretos ou com status neutro eram produtos de higiene pessoal básicos, medicamentos domésticos, despertador de quarto, utensílios de cozinha e limpeza doméstica (Griskevicius, et al., 2007). Os participantes responderam em uma escala de nove pontos, variando de 1: “Eu compraria itens muito baratos” a 9: “Eu compraria itens muito caros”. Na condição pública, os participantes foram informados de que estávamos trabalhando em um site onde as pessoas pudessem se encontrar. Este site nos ajudaria a investigar como as pessoas formam impressões entre si com base nos padrões de consumo. Os participantes leram que primeiro teriam que indicar quanto gastariam em alguns produtos. Suas escolhas seriam resumidas em um perfil. Os outros participantes da sessão teriam que formar impressões sobre eles com base nesse perfil. Depois de ver um exemplo da aparência do perfil, os participantes passaram para a mesma medida de consumo da condição privada. Em suma, o experimento tem um design 2 (poder: alto vs. baixo) x 2 (público: público vs. privado) x 2 (consumo: conspícuo vs. discreto) com poder e audiência manipulados entre os sujeitos e consumo manipulado entre os sujeitos. As hipóteses neste experimento foram as seguintes: Na condição de privado, esperávamos que os participantes de baixa potência tivessem uma WTP maior do que os participantes de alta potência para produtos visíveis, mas não para produtos discretos. Esse padrão de resultados replicaria os resultados de Rucker e Galinsky (2008). Esperávamos que a manipulação pública versus privada reduzisse a WTP para produtos visíveis para participantes de baixa potência, mas não para participantes de alta potência.Não esperávamos um efeito da manipulação pública versus privada na WTP para produtos discretos para participantes de baixa ou alta potência. Este experimento é descrito com mais detalhes em minha tese de doutorado (Franssens, 2016) Referências Cassidy, T., &amp; Lynn, R. (1989). A multifactorial approach to achievement motivation: The development of a comprehensive measure. Journal of Occupational Psychology, 62(4), 301-312. Franssens, S. (2016). Essays in consumer behavior (Doctoral dissertation). KU Leuven, Leuven, Belgium. Galinsky, A. D., Gruenfeld, D. H., &amp; Magee, J. C. (2003). From Power to action. Journal of Personality and Social Psychology, 85(3), 453-466. https://doi.org/10.1037/0022-3514.85.3.453 Griskevicius, V., Tybur, J. M., Sundie, J. M., Cialdini, R. B., Miller, G. F., &amp; Kenrick, D. T. (2007). Blatant benevolence and conspicuous consumption: When romantic motives elicit strategic costly signals. Journal of Personality and Social Psychology, 93(1), 85-102. https://doi.org/10.1037/0022-3514.93.1.85 Mead, N. L., &amp; Maner, J. K. (2012). On keeping your enemies close: Powerful leaders seek proximity to ingroup power threats. Journal of Personality and Social Psychology, 102(3), 576-591. https://doi.org/10.1037/a0025755 Rucker, D. D., &amp; Galinsky, A. D. (2008). Desire to acquire: Powerlessness and compensatory consumption. Journal of Consumer Research, 35(2), 257-267. https://doi.org/10.1086/588569 Dados Importação Faça o download dos dados aqui. Como sempre, salve os dados em um diretório (de preferência um backup automático do software de compartilhamento de arquivos) e inicie seu script carregando o tidyverse e definindo o diretório de trabalho no diretório em que você acabou de salvar seus dados: #library(tidyverse) #library(readxl) # precisamos deste pacote pois nossos dados estao num arquivo Excel #setwd(&quot;c:/dropbox/work/teaching/R/&quot;) # mudando para o nosso diretorio de trabalho #powercc &lt;- read_excel(&quot;power_conspicuous_consumption.xlsx&quot;,&quot;data&quot;) # Importe o arquivo Excel. Perceba que o nome da aba do Excel eh data library(readxl) url&lt;-&quot;http://users.telenet.be/samuelfranssens/tutorial_data/power_conspicuous_consumption.xlsx&quot; powercc &lt;- tempfile() download.file(url, powercc, mode=&quot;wb&quot;) powercc&lt;-read_excel(path = powercc, sheet = 1) powercc ## # A tibble: 147 x 39 ## subject start_date end_date duration finished power audience ## &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2012-04-19 09:32:56 2012-04-19 09:49:42 1006. 1 high public ## 2 2 2012-04-19 09:31:26 2012-04-19 09:51:13 1187. 1 low public ## 3 3 2012-04-19 09:29:50 2012-04-19 09:53:10 1400. 1 low public ## 4 4 2012-04-19 09:26:25 2012-04-19 09:53:21 1616. 1 low public ## 5 5 2012-04-19 09:20:55 2012-04-19 09:54:21 2006. 1 high public ## 6 6 2012-04-19 09:28:02 2012-04-19 09:55:50 1668. 1 high public ## 7 7 2012-04-19 09:17:54 2012-04-19 09:58:49 2455. 1 low public ## 8 8 2012-04-19 09:22:26 2012-04-19 10:01:40 2354. 1 high public ## 9 9 2012-04-19 10:13:12 2012-04-19 10:31:03 1071. 1 low public ## 10 10 2012-04-19 10:12:55 2012-04-19 10:31:29 1114. 1 high public ## # ... with 137 more rows, and 32 more variables: group_size &lt;dbl&gt;, gender &lt;chr&gt;, ## # age &lt;dbl&gt;, dominance1 &lt;dbl&gt;, dominance2 &lt;dbl&gt;, dominance3 &lt;dbl&gt;, dominance4 &lt;dbl&gt;, ## # dominance5 &lt;dbl&gt;, dominance6 &lt;dbl&gt;, dominance7 &lt;dbl&gt;, sa1 &lt;dbl&gt;, sa2 &lt;dbl&gt;, sa3 &lt;dbl&gt;, ## # sa4 &lt;dbl&gt;, sa5 &lt;dbl&gt;, sa6 &lt;dbl&gt;, sa7 &lt;dbl&gt;, sa8 &lt;dbl&gt;, sa9 &lt;dbl&gt;, sa10 &lt;dbl&gt;, ## # sa11 &lt;dbl&gt;, inconspicuous1 &lt;dbl&gt;, inconspicuous2 &lt;dbl&gt;, inconspicuous3 &lt;dbl&gt;, ## # inconspicuous4 &lt;dbl&gt;, inconspicuous5 &lt;dbl&gt;, conspicuous1 &lt;dbl&gt;, conspicuous2 &lt;dbl&gt;, ## # conspicuous3 &lt;dbl&gt;, conspicuous4 &lt;dbl&gt;, conspicuous5 &lt;dbl&gt;, agree &lt;dbl&gt; Não se esqueça de salvar seu script no diretório de trabalho. Manipulação Temos 39 colunas ou variáveis em nossos dados: subject identifica os participantes start_date e end_date indicam o início e o fim da sessão experimental. duration indica a duração da sessão experimental finished: os participantes concluíram todo o experimento? power (alto vs. baixo) e público (privado vs. público) são as condições experimentais group_size: em grupos de quantos participantes compareceram ao laboratório? gender e age do participante dominance1, dominance2, etc. são as perguntas que mediram a dominância. Um exemplo é “Eu acho que gostaria de ter autoridade sobre outras pessoas”. Os participantes responderam com sim (1) ou não (0). sa1, sa2 etc. são as perguntas que medem as aspirações de status. Um exemplo é: “Gostaria de um trabalho importante, onde as pessoas me admirassem”. Os participantes responderam com sim (1) ou não (0). inconspicuous1, inconspicuous2, etc. contêm a WTP para os produtos inconspicuous. Escala de 1: eu compraria itens muito baratos a 9: eu compraria itens muito caros. conspicuous1, conspicuous2, etc. contêm a WTP para os produtos conspícuos. Escala de 1: eu compraria itens muito baratos a 9: eu compraria itens muito caros. agree: uma questão exploratória que mede se as pessoas concordam que elas são mais adequadas ao papel de trabalhador ou gerente. Os participantes responderam em uma escala de 1: muito mais adequado para a função de trabalhador (gerente) a 7: muito mais adequado para a função de gerente (trabalhador). Números mais altos indicam concordância com a atribuição de função no experimento. Fatorar algumas variáveis Após a inspeção dos dados, vemos que o tipo de subject é duplo, o que significa que o subject deve ser fatorado para que seus valores não sejam tratados como números. Também fatoraremos nossas condições experimentais: library(dplyr) powercc &lt;- powercc %&gt;% # nos criamos o objeto powercc anteriormente mutate(subject = factor(subject), power = factor(power, levels = c(&quot;low&quot;,&quot;high&quot;)), # note os niveis dos argumentos audience = factor(audience, levels = c(&quot;private&quot;,&quot;public&quot;))) # note os niveis dos argumentos Observe que fornecemos novos levels de argumento ao fatorar poder e público. Este argumento especifica a ordem dos levels de um fator. No contexto desse experimento, é mais natural falar sobre o efeito da alta versus baixa potência no consumo do que falar sobre o efeito da baixa versus alta potência no consumo. Portanto, dizemos ao R que o baixo nível de energia deve ser considerado como o primeiro nível. Mais adiante, veremos que o resultado das análises pode ser interpretado como efeitos de alta potência (segundo nível) vs. baixa potência (primeiro nível). O mesmo raciocínio se aplica ao fator público, embora não seja necessário fornecer os níveis para esse fator porque o privado vem antes do público em ordem alfabética. Sua escolha do nível para o primeiro ou nível de referência influencia apenas a interpretação, não o resultado real da análise. Em uma sessão experimental, o alarme de incêndio disparou e tivemos que sair do laboratório. Vamos remover os participantes que não concluíram a experiência: powercc &lt;- powercc %&gt;% # nos ja criamos o objeto powercc anteriormente filter(finished == 1) # somente mantenha as observacoes que sao terminadas ou iguais a 1 Observe o dobro \\(==\\) ao testar a igualdade. Confira o livro R4 Data Science para outros operadores lógicos (role para baixo para chegar à Seção 5.2.2). Calcular a consistência interna e a média de perguntas que medem o mesmo conceito Gostaríamos de calcular a média das perguntas que medem a dominância para obter um único número indicando se o participante tem uma personalidade dominante ou não dominante. Antes de fazer isso, devemos ter uma idéia da consistência interna das perguntas que medem o domínio. Isso nos dirá se todas essas perguntas medem o mesmo conceito. Uma medida da consistência interna é o alfa de Cronbach. Para calcular, precisamos de um pacote chamado psych: #install.packages(&quot;psych&quot;) library(psych) ## ## Attaching package: &#39;psych&#39; ## The following object is masked from &#39;package:car&#39;: ## ## logit ## The following object is masked from &#39;package:Hmisc&#39;: ## ## describe ## The following objects are masked from &#39;package:ggplot2&#39;: ## ## %+%, alpha Depois que o pacote for carregado, podemos usar a função alfa para calcular o alfa de Cronbach para um conjunto de perguntas: dominance.questions &lt;- powercc %&gt;% select(starts_with(&quot;dominance&quot;)) # pegue o dataframe powercc e selecione todas as viariaveis com o nome que se inicia com dominancia alpha(dominance.questions) # calcula o alfa de cronbach para essas variaveis ## ## Reliability analysis ## Call: alpha(x = dominance.questions) ## ## raw_alpha std.alpha G6(smc) average_r S/N ase mean sd median_r ## 0.69 0.67 0.67 0.23 2.1 0.038 0.63 0.27 0.21 ## ## lower alpha upper 95% confidence boundaries ## 0.61 0.69 0.76 ## ## Reliability if an item is dropped: ## raw_alpha std.alpha G6(smc) average_r S/N alpha se var.r med.r ## dominance1 0.68 0.67 0.66 0.25 2.0 0.039 0.016 0.22 ## dominance2 0.65 0.63 0.62 0.22 1.7 0.043 0.018 0.21 ## dominance3 0.59 0.58 0.56 0.19 1.4 0.050 0.014 0.20 ## dominance4 0.62 0.60 0.59 0.20 1.5 0.047 0.018 0.21 ## dominance5 0.65 0.64 0.63 0.23 1.7 0.043 0.021 0.21 ## dominance6 0.70 0.70 0.68 0.28 2.4 0.038 0.009 0.25 ## dominance7 0.65 0.64 0.62 0.23 1.8 0.043 0.017 0.20 ## ## Item statistics ## n raw.r std.r r.cor r.drop mean sd ## dominance1 143 0.52 0.49 0.33 0.29 0.53 0.50 ## dominance2 143 0.59 0.61 0.52 0.42 0.80 0.40 ## dominance3 143 0.75 0.74 0.71 0.59 0.52 0.50 ## dominance4 143 0.68 0.68 0.61 0.50 0.58 0.50 ## dominance5 143 0.61 0.59 0.48 0.40 0.55 0.50 ## dominance6 143 0.29 0.38 0.19 0.14 0.91 0.29 ## dominance7 143 0.62 0.59 0.48 0.41 0.53 0.50 ## ## Non missing response frequency for each item ## 0 1 miss ## dominance1 0.47 0.53 0 ## dominance2 0.20 0.80 0 ## dominance3 0.48 0.52 0 ## dominance4 0.42 0.58 0 ## dominance5 0.45 0.55 0 ## dominance6 0.09 0.91 0 ## dominance7 0.47 0.53 0 # Observe que também poderíamos ter escrito isso da seguinte maneira: # powercc %&gt;% select(starts_with(&quot;dominance&quot;)) %&gt;% cronbach() Isso produz muita saída. Em raw_alpha, vemos que o alfa é 0,69, que fica no lado inferior (0,70 é geralmente considerado o mínimo necessário), mas ainda está ok. A tabela abaixo nos diz qual seria o alfa se retirássemos uma pergunta de nossa medida. A queda da dominance6 aumentaria o alfa para 0,7. Comparado ao alfa original de 0,69, esse aumento é pequeno e, portanto, não perdemos a dominance6. Se houvesse uma pergunta com um alto “alfa se descartado”, isso indicaria que esta pergunta está medindo algo diferente das outras perguntas. Nesse caso, você pode considerar remover esta pergunta da sua medida. Podemos proceder calculando a média das respostas sobre a questão do domínio: powercc &lt;- powercc %&gt;% mutate(dominance = (dominance1+dominance2+dominance3+dominance4+dominance5+dominance6+dominance7)/7, cc = (conspicuous1+conspicuous2+conspicuous3+conspicuous4+conspicuous5)/5, icc = (inconspicuous1+inconspicuous2+inconspicuous3+inconspicuous4+inconspicuous5)/5) %&gt;% select(-starts_with(&quot;sa&quot;)) Também calculei a média das perguntas sobre consumo conspícuo e consumo discreto, mas não sobre as aspirações de status porque o alfa de Cronbach era muito baixo. Excluí as perguntas sobre aspirações de status do conjunto de dados. Deixo como um exercício verificar os alfa de Cronbach de cada um desses conceitos (faça isso antes de excluir as perguntas sobre as aspirações de status, é claro). Recapitulando: importando e manipulando Aqui está o que fizemos até agora, em uma sequência ordenada de operações canalizadas (faça o download dos dados aqui}): #library(tidyverse) #library(readxl) #setwd(&quot;c:/dropbox/work/teaching/R/&quot;) # mudando para seu proprio diretorio #powercc &lt;- read_excel(&quot;power_conspicuous_consumption.xlsx&quot;,&quot;data&quot;) %&gt;% # filter(finished == 1) %&gt;% #mutate(subject = factor(subject), # power = factor(power, levels = c(&quot;low&quot;,&quot;high&quot;)), # audience = factor(audience, levels = c(&quot;private&quot;,&quot;public&quot;)), # dominance = (dominance1+dominance2+dominance3+dominance4+dominance5+dominance6+dominance7)/7, # cc = (conspicuous1+conspicuous2+conspicuous3+conspicuous4+conspicuous5)/5, # icc = (inconspicuous1+inconspicuous2+inconspicuous3+inconspicuous4+inconspicuous5)/5) %&gt;% # select(-starts_with(&quot;sa&quot;)) Teste \\(t\\) Teste \\(t\\) para amostras independentes Digamos que queremos testar se homens e mulheres diferem no grau em que são dominantes. Vamos criar um boxplot primeiro e depois verificar as médias e os desvios padrão: library(ggplot2) ggplot(data = powercc, mapping = aes(x = gender, y = dominance)) + geom_boxplot() powercc %&gt;% group_by(gender) %&gt;% summarise(mean_dominance = mean(dominance), sd_dominance = sd(dominance)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 3 ## gender mean_dominance sd_dominance ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 female 0.614 0.247 ## 2 male 0.646 0.296 Os homens pontuam um pouco mais alto que as mulheres, mas queremos saber se essa diferença é significativa. Um teste \\(t\\) de amostras independentes pode fornecer a resposta (os homens e as mulheres em nosso experimento são amostras independentes), mas precisamos verificar primeiro uma suposição: as variações das duas amostras independentes são iguais? #install.packages(&quot;car&quot;) # para o teste de variancias iguais, precisamos de um pacote chamado car library(car) # Teste Levene para igualdade de variancias. # Baixo valor-p indica que as variancias nao sejam iguais. # Primeiro argumento = variavel dependente continua, segundo argumento = variavel independente categorica leveneTest(powercc$dominance, powercc$gender) ## Warning in leveneTest.default(powercc$dominance, powercc$gender): powercc$gender coerced to ## factor. ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 1 2.1915 0.141 ## 141 A hipótese nula de variâncias iguais não é rejeitada (\\(p = 0,14\\)), para que possamos continuar com um teste \\(t\\) que assume variâncias iguais: # Teste se os meios de dominancia diferem entre os sexos. # Indique se o teste deve assumir variacoes iguais ou nao (define var.equal = FALSE para um teste que nao assume variacoes iguais). t.test(powercc$dominance ~ powercc$gender, var.equal = TRUE) ## ## Two Sample t-test ## ## data: powercc$dominance by powercc$gender ## t = -0.6899, df = 141, p-value = 0.4914 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.12179092 0.05877722 ## sample estimates: ## mean in group female mean in group male ## 0.6142857 0.6457926 Você pode relatar o seguinte: “Homens (\\(M = 0,65, DP = 0,3\\)) e mulheres (\\(M = 0,61, DP = 0,25\\)) não diferiram no grau em que se classificaram como dominantes (\\(t (141) = -0,69 , p = 0,49\\)).” Teste \\(t\\) para amostras dependentes Digamos que queremos testar se as pessoas estão mais dispostas a gastar em itens conspícuos do que em itens discretos. Vamos verificar os meios e os desvios padrão primeiro: powercc %&gt;% # nao ha necessidade de agrupar! nao estamos dividindo nossa amostra em subgrupos summarise(mean_cc = mean(cc), sd_cc = sd(cc), mean_icc = mean(icc), sd_icc = sd(icc)) ## # A tibble: 1 x 4 ## mean_cc sd_cc mean_icc sd_icc ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6.01 1.05 3.60 0.988 As médias são mais altas para produtos conspícuos do que para produtos discretos, mas queremos saber se essa diferença é significativa e, portanto, realizar um teste t de amostras dependentes (cada participante classifica produtos conspícuos e discretos, portanto, essas classificações são dependentes): t.test(powercc$cc, powercc$icc, paired = TRUE) # Teste se as medias de cc e icc sao diferentes. Indique que este eh um teste t de amostras dependentes com emparelhado = TRUE. ## ## Paired t-test ## ## data: powercc$cc and powercc$icc ## t = 25.064, df = 142, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 2.214575 2.593816 ## sample estimates: ## mean of the differences ## 2.404196 Você pode relatar o seguinte: “As pessoas indicaram que estavam dispostas a pagar mais (\\(t (142) = 25.064\\), \\(p &lt;0,001\\)) por produtos conspícuos (\\(M = 6,01, DP = 1,05\\)) do que por produtos discretos (\\(M = 3,6, DP = 0,99\\)).” Teste \\(t\\) para amostra única Digamos que queremos testar se a disposição média de pagar pelos itens visíveis foi significativamente maior que 5 (o ponto médio da escala): t.test(powercc$cc, mu = 5) # Indique a variavel cuja media queremos comparar com um valor especifico (5). ## ## One Sample t-test ## ## data: powercc$cc ## t = 11.499, df = 142, p-value &lt; 2.2e-16 ## alternative hypothesis: true mean is not equal to 5 ## 95 percent confidence interval: ## 5.833886 6.180100 ## sample estimates: ## mean of x ## 6.006993 Na verdade, é significativamente maior que 5. Você pode relatar o seguinte: “A WTP média para produtos conspícuos (M = 6,01, DP = 1,05) estava significativamente acima de 5 (t (142) = 11,499, \\(p &lt;0,001\\)).” ANOVA Bivariada Quando você lê um artigo acadêmico que relata um experimento, a seção de resultados geralmente começa com uma discussão dos principais efeitos dos fatores experimentais e sua interação, conforme testado por uma Análise de variância ou ANOVA. Vamos nos concentrar primeiro na WTP para produtos que melhoram o status. (Consideramos brevemente a WTP para produtos com status neutro em nossa discussão sobre testes t de amostras dependentes e discutiremos mais detalhadamente na seção ANOVA de medidas repetidas.) Vamos inspecionar algumas estatísticas descritivas primeiro. Gostaríamos de ver a WTP média para produtos visíveis, o desvio padrão dessa WTP e o número de participantes em cada célula experimental. Já aprendemos como fazer isso no capítulo introdutório (consulte as tabelas de frequência e as estatísticas descritivas): powercc.summary &lt;- powercc %&gt;% # estamos atribuindo o resumo a um objeto, porque precisaremos desse resumo para fazer um grafico de barras group_by(audience, power) %&gt;% # agora agrupamos por duas variaveis summarise(count = n(), mean = mean(cc), sd = sd(cc)) ## `summarise()` regrouping output by &#39;audience&#39; (override with `.groups` argument) powercc.summary ## # A tibble: 4 x 5 ## # Groups: audience [2] ## audience power count mean sd ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 private low 34 6.08 1.04 ## 2 private high 31 5.63 0.893 ## 3 public low 40 6.17 1.15 ## 4 public high 38 6.07 1.03 Vemos que a diferença na WTP entre os participantes de alta e baixa potência é maior na condição privada do que na pública. Vamos resumir esses resultados em um gráfico de caixa: # ao criar um grafico de caixa, o conjunto de dados que serve como entrada para o ggplot eh o conjunto de dados completo, nao o resumo com os meios ggplot(data = powercc, mapping = aes(x = audience, y = cc, fill = power)) + geom_boxplot() # argumentos sao os mesmos que para geom_bar, mas agora fornecemos a geom_boxplot Os gráficos boxplot são informativos porque nos dão uma idéia da mediana e da distribuição dos dados. No entanto, em trabalhos acadêmicos, os resultados das experiências são tradicionalmente resumidos em gráficos de barras (mesmo que os gráficos boxplots sejam mais informativos). # ao criar um grafico de barras, o conjunto de dados que serve como entrada para o ggplot eh o resumo com os meios, nao o conjunto de dados completo ggplot(data = powercc.summary, mapping = aes(x = audience, y = mean, fill = power)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) Para criar um gráfico de barras, informamos ao ggplot as variáveis que devem estar no eixo X e no eixo Y e também usamos cores diferentes para diferentes níveis de potência com o comando fill. Então pedimos um gráfico de barras com geom_bar. stat = “identity” e position = “dodge” devem ser incluídos como argumentos para geom_bar, mas uma discussão sobre esses argumentos está além do escopo deste tutorial. Antes de prosseguirmos com a ANOVA, devemos verificar se suas premissas são atendidas. Discutimos as suposições da ANOVA anteriormente, mas ignoramos aqui. Para realizar uma ANOVA, precisamos instalar alguns pacotes: #install.packages(remotes) # O pacote de controles remotos nos permite instalar pacotes armazenados no GitHub, um site para desenvolvedores de pacotes. #install.packages(&quot;car&quot;) # Tambem precisaremos do pacote do carro para executar a ANOVA (não é necessário reinstala-lo se você já tiver feito isso). library(remotes) install_github(&#39;samuelfranssens/type3anova&#39;) # Instale o pacote type3anova. Esta e as etapas anteriores precisam ser executadas apenas uma vez. ## Skipping install of &#39;type3anova&#39; from a github remote, the SHA1 (0c38377d) has not changed since last install. ## Use `force = TRUE` to force installation library(type3anova) # Carrega o pacote type3anova Agora podemos prosseguir com a ANOVA real: # Cria um modelo linear primeiramente # A funcao lm() toma os dados e os argumentos # A formula tem a seguinte sintaxe: variavel dependente ~ variavel independente linearmodel &lt;- lm(cc ~ power*audience, data=powercc) # power*audience: interacao eh calculada # power+audience: interacao nao eh incluida type3anova(linearmodel) # Em seguida, peça a saída no formato ANOVA. Isso fornece a soma dos quadrados do Tipo III. Observe que isso é diferente da anova (modelo linear), que fornece a soma dos quadrados do tipo I. ## # A tibble: 5 x 6 ## term ss df1 df2 f pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 5080. 1 139 4710. 0 ## 2 power 2.64 1 139 2.45 0.12 ## 3 audience 2.48 1 139 2.30 0.132 ## 4 power:audience 1.11 1 139 1.03 0.313 ## 5 Residuals 150. 139 139 NA NA Você pode relatar esses resultados da seguinte forma: “Nem o principal efeito do poder (F (1, 139) = 2,45, p = 0,12), nem o principal efeito do público (F (1, 139) = 2,3, p = 0,13), nem a interação entre poder e público (F (1, 139) = 1,03, p = 0,31) foi significativa.” Seguindo com contrastes Ao realizar um experimento 2 x 2, geralmente fazemos a hipótese de uma interação. Uma interação significa que o efeito de uma variável independente é diferente dependendo dos níveis da outra variável independente. Na seção anterior, a ANOVA nos disse que a interação entre poder e público não era significativa. Isso significa que o efeito de alta versus baixa potência foi o mesmo na condição privada e pública e que o efeito de público versus privado foi o mesmo na condição de alta e baixa potência. Normalmente, a análise para com a não significância da interação. No entanto, faremos os testes de acompanhamento que um faria se a interação fosse significativa. Vamos considerar o significado da célula novamente: powercc.summary &lt;- powercc %&gt;% group_by(audience, power) %&gt;% summarise(count = n(), mean = mean(cc), sd = sd(cc)) ## `summarise()` regrouping output by &#39;audience&#39; (override with `.groups` argument) # ao criar um grafico de barras, o conjunto de dados que serve como entrada para o ggplot eh o resumo com os meios, nao o conjunto de dados completo ggplot(data = powercc.summary,mapping = aes(x = audience, y = mean, fill = power)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) powercc.summary ## # A tibble: 4 x 5 ## # Groups: audience [2] ## audience power count mean sd ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 private low 34 6.08 1.04 ## 2 private high 31 5.63 0.893 ## 3 public low 40 6.17 1.15 ## 4 public high 38 6.07 1.03 Queremos testar se a diferença entre alta e baixa potência na condição privada é significativa (baixa: 6,08 vs. alta: 5,63) e se a diferença entre alta e baixa potência na condição pública é significativa (baixa: 6,17 vs. alta : 6,07). Para fazer isso, podemos usar a função de contraste da biblioteca type3anova que instalamos anteriormente. A função de contraste usa dois argumentos: um modelo linear e uma especificação de contraste. O modelo linear é o mesmo de antes: linearmodel &lt;- lm(cc ~ power*audience, data=powercc) Mas, para saber como devemos especificar nosso contraste, precisamos dar uma olhada nos coeficientes de regressão em nosso modelo linear: summary(linearmodel) ## ## Call: ## lm(formula = cc ~ power * audience, data = powercc) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.7700 -0.6737 0.1177 0.7177 2.3263 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 6.08235 0.17812 34.148 &lt;2e-16 *** ## powerhigh -0.45009 0.25792 -1.745 0.0832 . ## audiencepublic 0.08765 0.24226 0.362 0.7181 ## powerhigh:audiencepublic 0.35378 0.34910 1.013 0.3126 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.039 on 139 degrees of freedom ## Multiple R-squared: 0.03711, Adjusted R-squared: 0.01633 ## F-statistic: 1.786 on 3 and 139 DF, p-value: 0.1527 Temos 4 coeficientes de regressão: \\(\\beta_{0}\\) ou intercepto \\(\\beta_{1}\\) ou o coeficiente de powerhigh ou o alto nível do fator de potência (-0,45) \\(\\beta_{2}\\) ou o coeficiente para audiencepublic ou o nível público do fator público (0,09) \\(\\beta_{3}\\) ou coeficiente para: powerhigh:audiencepublic (0.35) Vemos que a estimativa para a interceptação corresponde à média observada na célula privada de baixa potência. Adicione a isso a estimativa de powerhigh e obteremos a média observada na célula privada de alta potência. Adicione à estimativa para a interceptação, a estimativa de audiencepublic e obtenha a média observada na célula pública de baixa potência. Adicione à estimativa para a interceptação, a estimativa de powerhigh, audiencepublic e powerhigh:audiencepublic e obteremos a média observada na célula pública de alto poder. Geralmente visualizo isso em uma tabela (e salvo no meu script) para facilitar a especificação do contraste que quero testar: Digamos que estamos contrastando energia alta versus baixa na condição privada e testamos se (\\(\\beta_{0}+\\beta_{1}\\) e \\(\\beta_{0}\\) diferem significativamente ou se (\\(\\beta_{0}+\\beta_{1})-\\beta_{0}=\\beta_{1}\\) é significativamente diferente de zero. Nós especificamos isso da seguinte maneira: contrast_specification &lt;- c(0, 1, 0, 0) # os quatro numeros correspondentes a b0, b1, b2, b3. # queremos testar se b1 eh significativo, entao colocamos 1 em 2º lugar (o 1º lugar é para b0) #contrast(linearmodel, contrast_specification) ## ## Simultaneous Tests for General Linear Hypotheses ## ## Fit: aov(formula = linearmodel) ## ## Linear Hypotheses: ## Estimate Std. Error t value Pr(&gt;|t|) ## 1 == 0 -0.4501 0.2579 -1.745 0.0832 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## (Adjusted p values reported -- single-step method) A saída nos diz que a estimativa do contraste é -0,45, que é realmente a diferença entre as médias observadas na condição privada (alta potência: 5,63 vs. baixa potência: 6,08). Você pode relatar esse resultado da seguinte forma: “O efeito de alta (M = 5,63, DP = 0,89) vs. baixa potência (M = 6,08, DP = 1,04) na condição privada foi marginalmente significativo (t (139) = -1,745 , p = 0,083).” Para obter os graus de liberdade, faça um contraste (linearmodel, contrast_specification)$df} Digamos que queremos testar um contraste mais complicado, ou seja, se a média na célula privada de alta potência é diferente da média das médias nas outras células. Estamos testando: \\((\\beta_0 + \\beta_1)-1/3*[(\\beta_0)+(\\beta_0 +\\beta_2)+(\\beta_0+\\beta_1+\\beta_2+\\beta_3)]\\) \\(=\\beta_1-1/3*(\\beta_1+2\\beta_2+\\beta_3)\\) \\(=2/3 * \\beta_1-2/3 * \\beta_2-1/3 * \\beta_3\\) A especificação de contraste é a seguinte: contrast_specification &lt;- c(0, 2/3, -2/3, -1/3) #contrast(linearmodel, contrast_specification) ## ## Simultaneous Tests for General Linear Hypotheses ## ## Fit: aov(formula = linearmodel) ## ## Linear Hypotheses: ## Estimate Std. Error t value Pr(&gt;|t|) ## 1 == 0 -0.4764 0.2109 -2.259 0.0254 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## (Adjusted p values reported -- single-step method) Verifique se a estimativa realmente corresponde à diferença entre a média de alta potência, privada e a média das médias nas outras células. Você pode relatar o seguinte: “A célula privada de alta potência tinha uma WTP significativamente menor do que as outras células experimentais em nosso projeto (est = -0,476, t (139) = -2,259, p = 0,025)”. Análise de moderação: interação entre variáveis independentes contínuas e categóricas Digamos que queremos testar se os resultados do experimento dependem do nível de domínio das pessoas. Em outras palavras, os efeitos do poder e da audiência são diferentes para participantes dominantes versus participantes não dominantes? Ainda em outras palavras, existe uma interação de três vias entre poder, audiência e domínio? Vamos criar um gráfico primeiro: # Nossa variavel dependente eh o consumo conspicuo, nossa variavel independente (no eixo X) eh a dominancia. # Entao, estamos tracando a relacao entre dominancia e consumo conspicuo. # O argumento da cor diz a R que queremos um relacionamento para cada nivel de poder. ggplot(data = powercc, mapping = aes(x = dominance, y = cc, color = power)) + facet_wrap(~ audience) + # Diga a R que tambem queremos dividir por audiencia. geom_jitter() + # Use geom_jitter em vez de geom_point, caso contrario, os pontos serao desenhados um sobre o outro geom_smooth(method=&#39;lm&#39;, se=FALSE) # Desenhe uma linha de regressao linear atraves dos pontos. ## `geom_smooth()` using formula &#39;y ~ x&#39; Este gráfico é informativo. Isso nos mostra que, na condição privada, o efeito da alta versus baixa potência no consumo conspícuo é mais negativo para participantes menos dominantes do que para participantes mais dominantes. Na condição pública, o efeito da alta versus baixa potência no consumo conspícuo não difere entre os participantes menos versus os mais dominantes. Também vemos que, tanto na condição privada quanto na pública, os participantes mais vs. menos dominantes estão mais dispostos a gastar em consumo conspícuo. Vamos verificar se a interação de três vias é significativa: linearmodel &lt;- lm(cc ~ power * audience * dominance, data = powercc) type3anova(linearmodel) ## # A tibble: 9 x 6 ## term ss df1 df2 f pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 525. 1 135 519. 0 ## 2 power 2.21 1 135 2.18 0.142 ## 3 audience 0.715 1 135 0.706 0.402 ## 4 dominance 10.5 1 135 10.3 0.002 ## 5 power:audience 1.44 1 135 1.42 0.235 ## 6 power:dominance 1.18 1 135 1.17 0.282 ## 7 audience:dominance 0.113 1 135 0.111 0.739 ## 8 power:audience:dominance 1.30 1 135 1.29 0.258 ## 9 Residuals 137. 135 135 NA NA Somente o efeito da dominância é significativa. Se a interação de três vias fosse significativa, poderíamos acompanhar com mais testes. Por exemplo, poderíamos testar se a interação bidirecional entre dominância e poder é significativa na condição privada, como sugere o gráfico. Para fazer isso, vamos primeiro examinar os coeficientes de regressão do nosso modelo linear: summary(linearmodel) ## ## Call: ## lm(formula = cc ~ power * audience * dominance, data = powercc) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.58617 -0.63357 0.09751 0.68310 2.24067 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 5.7553 0.6019 9.561 &lt;2e-16 *** ## powerhigh -1.2490 0.7703 -1.621 0.107 ## audiencepublic -0.1651 0.6918 -0.239 0.812 ## dominance 0.4526 0.7980 0.567 0.572 ## powerhigh:audiencepublic 1.1162 0.9355 1.193 0.235 ## powerhigh:dominance 1.5021 1.1111 1.352 0.179 ## audiencepublic:dominance 0.5434 0.9514 0.571 0.569 ## powerhigh:audiencepublic:dominance -1.5394 1.3561 -1.135 0.258 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.006 on 135 degrees of freedom ## Multiple R-squared: 0.1225, Adjusted R-squared: 0.07703 ## F-statistic: 2.693 on 7 and 135 DF, p-value: 0.01211 Temos oito termos em nosso modelo: \\(\\beta_0\\) ou intercepto; \\(\\beta_1\\) ou o coeficiente para -“powerhigh”- \\(\\beta_2\\) ou o coeficiente para -“audiencepublic”- \\(\\beta_3\\) ou o coeficiente para -“dominance”- \\(\\beta_4\\) ou o coeficiente para -“powerhigh:audiencepublic”- \\(\\beta_5\\) ou o coeficiente para -“powerhigh:dominance”- \\(\\beta_6\\) ou o coeficiente para -“audiencepublic:dominance”- \\(\\beta_7\\) ou o coeficiente para -“powerhigh:audiencepublic:dominance”- Resultando nessa tabela de coeficientes: # private public # low power [b0] + (b3) [b0+b2] + (b3+b6) # high power [b0+b1] + (b3+b5) [b0+b1+b2+b4] + (b3+b5+b6+b7) Como conseguimos essa tabela? Com o modelo linear especificado acima, cada valor estimado de consumo conspícuo (a variável dependente) é uma função da condição experimental do participante e do nível de dominância do participante. Digamos que tenhamos um participante na condição pública de baixa potência com um nível de dominância de 0,5. O valor estimado do consumo conspícuo para esse participante é: \\(\\beta_0\\) ou intercepto x 1; \\(\\beta_1\\) (porque o participante não está na condição de alta potência) \\(\\beta_2\\) × 1 (na condição pública) \\(\\beta_3\\) × 0.5 (dominance = 0.5) \\(\\beta_4\\) × 0 (não no poder superior e na condição pública) \\(\\beta_5\\) × 0 (não na condição de alta potência) \\(\\beta_6\\) × 1 x 0,5 (na condição pública e dominância = 0,5) \\(\\beta_7\\) × 0 (não no poder superior e na condição pública) ou \\[ \\beta_0 \\times 1 + \\beta_1 \\times 0 + \\beta_2 \\times 1 + \\beta_3 \\times 0.5 + \\beta_4 \\times 0 + \\beta_5 \\times 0 + \\beta_6 \\times 0.5 + \\beta_7 \\times 0 \\] \\(= [\\beta_0 + \\beta_2] + (\\beta_3 + \\beta_6) \\times 0.5\\) \\(= [5.76 + -0.17] + (0.45 + 0.54) * 0.5 = 6.09\\) Verifique o gráfico para ver se isso realmente corresponde ao consumo conspícuo estimado de um participante com dominância = 0,5 na célula pública de baixa potência. A fórmula geral para a célula pública de baixa potência é a seguinte: \\[ [\\beta_0 + \\beta_2] + (\\beta_3 + \\beta_6)\\times\\mbox{dominance} \\] e podemos obter as fórmulas para as diferentes células de maneira semelhante. Vemos que em cada célula, o coeficiente entre colchetes é o valor estimado na medida de consumo conspícuo para um participante que pontua 0 em dominância. O coeficiente entre parênteses arredondados é o aumento estimado na medida de consumo conspícuo para cada aumento de uma unidade no domínio. Em outras palavras, os coeficientes entre colchetes representam a interceptação e os coeficientes entre colchetes representam a inclinação da linha que representa a regressão do consumo conspícuo (Y) na dominância (X) dentro de cada célula experimental (ou seja, cada potência e público-alvo) combinação). Um teste da interação entre poder e dominância dentro da condição privada se resumiria a testar se as linhas azul e vermelha no painel esquerdo da figura acima devem ser consideradas paralelas ou não. Se eles são paralelos, o efeito da dominância no consumo conspícuo é o mesmo nas condições de baixa e alta potência. Se eles não são paralelos, o efeito da dominância é diferente nas condições de baixa e alta potência. Em outras palavras, devemos testar se os coeficientes de regressão são iguais dentro de baixa potência, privado e dentro de alta potência, privado. Em outras palavras, testamos se \\((\\beta_3+\\beta_5)-\\beta_3=\\beta_5\\) é igual a zero: # agora temos oito numeros correspondentes aos oito coeficientes de regressao # queremos testar se b5 eh significativo, entao colocamos 1 em 6º lugar (o 1º lugar é para b0) contrast_specification &lt;- c(0, 0, 0, 0, 0, 1, 0, 0) #contrast(linearmodel, contrast_specification) ## ## Simultaneous Tests for General Linear Hypotheses ## ## Fit: aov(formula = linearmodel) ## ## Linear Hypotheses: ## Estimate Std. Error t value Pr(&gt;|t|) ## 1 == 0 1.502 1.111 1.352 0.179 ## (Adjusted p values reported -- single-step method) A interação não é significativa, no entanto. Você pode relatar o seguinte: “Dentro da condição privada, não houve interação entre poder e dominância (t (135) = 1,352, p = 0,18).” Análise spotlight Em breve. Análise ANCOVA Descobrimos que nossas condições experimentais não afetam significativamente o consumo conspícuo: linearmodel1 &lt;- lm(cc ~ power*audience, data = powercc) type3anova(linearmodel1) ## # A tibble: 5 x 6 ## term ss df1 df2 f pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 5080. 1 139 4710. 0 ## 2 power 2.64 1 139 2.45 0.12 ## 3 audience 2.48 1 139 2.30 0.132 ## 4 power:audience 1.11 1 139 1.03 0.313 ## 5 Residuals 150. 139 139 NA NA Por um lado, isso pode significar que simplesmente não há efeitos das condições experimentais no consumo conspícuo. Por outro lado, isso poderia significar que as manipulações experimentais não são fortes o suficiente ou que há muita variação inexplicada em nossa variável dependente (ou ambas). Podemos reduzir a variação inexplicável em nossa variável dependente, no entanto, incluindo uma variável em nosso modelo que suspeitamos estar relacionada à variável dependente. No nosso caso, suspeitamos que a disposição de gastar em consumo discreto (icc) esteja relacionada à disposição de gastar em consumo conspícuo. Embora icc seja uma variável contínua, podemos incluí-la como uma variável independente em nossa ANOVA e isso nos permitirá reduzir a variação inexplicável em nossa variável dependente: linearmodel2 &lt;- lm(cc ~ power*audience + icc, data = powercc) type3anova(linearmodel2) ## # A tibble: 6 x 6 ## term ss df1 df2 f pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 209. 1 138 221. 0 ## 2 power 1.88 1 138 1.99 0.16 ## 3 audience 1.14 1 138 1.21 0.274 ## 4 icc 19.6 1 138 20.8 0 ## 5 power:audience 1.96 1 138 2.08 0.152 ## 6 Residuals 130. 138 138 NA NA Vemos que icc está relacionado à variável dependente e, portanto, que a soma dos quadrados dos resíduos desse modelo, ou seja, a variação inexplicada em nossa variável dependente, é menor (130,32) do que a do modelo sem icc (149,93). Os valores p dos fatores experimentais não diminuem, no entanto. Você pode relatar o seguinte: “Controlando a disposição de gastar em consumo discreto, nem o principal efeito do poder (F (1, 138) = 1,99, p = 0,16), nem o principal efeito do público (F (1, 138 ) = 1,21, p = 0,27), nem a interação entre poder e público (F (1, 138) = 2,08, p = 0,15) foi significativa.” Chamamos essa análise de ANCOVA porque icc é uma covariável (abrange ou está relacionada à nossa variável dependente). Medidas repetidas ANOVA Neste experimento, temos mais de uma medida por unidade de observação, ou seja, disposição para gastar em produtos conspícuos e disposição para gastar em produtos discretos. Uma ANOVA de medidas repetidas pode ser usada para testar se os efeitos das condições experimentais são diferentes para produtos conspícuos versus inconspícuos. Para executar uma ANOVA de medidas repetidas, precisamos reestruturar nosso quadro de dados de amplo a longo. Um amplo quadro de dados possui uma linha por unidade de observação (em nosso experimento: uma linha por participante) e uma coluna por observação (em nosso experimento: uma coluna para os produtos conspícuos e uma coluna para os produtos inconspícuos). Um quadro de dados longo possui uma linha por observação (em nosso experimento: duas linhas por participante, uma linha para o produto conspícuo e uma linha para o produto inconspícuo) e uma coluna extra que indica com que tipo de observação estamos lidando (conspícua ou imperceptível). Vamos converter o quadro de dados e ver como os quadros de dados amplos e longos diferem um do outro. library(tidyr) powercc.long &lt;- powercc %&gt;% gather(consumption_type, wtp, cc, icc) # Converter de grande para longo significa que estamos empilhando varias colunas umas sobre as outras. Para isso, precisamos de uma variavel extra para acompanhar qual coluna estamos lidando. # A funcao de coleta converte conjuntos de dados de amplos para longos. # O primeiro argumento (consumer_type) nos dira com qual coluna estamos lidando. Essa eh a variavel que armazenara os nomes das colunas que estamos empilhando. # O segundo argumento (wtp) armazenara as colunas reais empilhadas umas sobre as outras. # Os argumentos a seguir sao as colunas que queremos empilhar. # Entao, dizemos ao gather para criar duas novas variaveis: tipo_de_consumo e vontade de pagar, para representar o empilhamento de um determinado numero de colunas. # Vamos dizer ao R para nos mostrar apenas as colunas relevantes (isto eh apenas para fins de apresentacao): powercc.long %&gt;% select(subject, power, audience, consumption_type, wtp) %&gt;% arrange(subject) ## # A tibble: 286 x 5 ## subject power audience consumption_type wtp ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 high public cc 5 ## 2 1 high public icc 2.6 ## 3 2 low public cc 7.6 ## 4 2 low public icc 4 ## 5 3 low public cc 5.4 ## 6 3 low public icc 3.4 ## 7 4 low public cc 8.4 ## 8 4 low public icc 5.2 ## 9 5 high public cc 7.8 ## 10 5 high public icc 3 ## # ... with 276 more rows Temos duas linhas por assunto, uma coluna de disposição para pagar e outra coluna (tipo de consumo) que indica se está disposta a pagar por produtos visíveis ou imperceptíveis. Compare isso com o amplo conjunto de dados: powercc %&gt;% select(subject, power, audience, cc, icc) %&gt;% arrange(subject) # Mostre somente as colunas relevantes ## # A tibble: 143 x 5 ## subject power audience cc icc ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 high public 5 2.6 ## 2 2 low public 7.6 4 ## 3 3 low public 5.4 3.4 ## 4 4 low public 8.4 5.2 ## 5 5 high public 7.8 3 ## 6 6 high public 7.2 5 ## 7 7 low public 4.8 4 ## 8 8 high public 6.6 4.4 ## 9 9 low public 5.8 4.2 ## 10 10 high public 6.8 3.4 ## # ... with 133 more rows Temos uma linha por assunto e duas colunas, uma para cada tipo de produto. Agora podemos realizar uma medida repetida ANOVA. Para isso, precisamos do pacote ez. #install.packages(&quot;ez&quot;) # Precisamos do pacote ez para RM ANOVA library(ez) ## Registered S3 methods overwritten by &#39;lme4&#39;: ## method from ## cooks.distance.influence.merMod car ## influence.merMod car ## dfbeta.influence.merMod car ## dfbetas.influence.merMod car Queremos testar se a interação entre poder e público é diferente para produtos conspícuos e inconspícuos. Vamos dar uma olhada em um gráfico primeiro: powercc.long.summary &lt;- powercc.long %&gt;% # para um grafico de barras precisamos de summary primeiro group_by(power, audience, consumption_type) %&gt;% # agrupa por tres variaveis independentes summarise(wtp = mean(wtp)) # obtem a media de wtp ## `summarise()` regrouping output by &#39;power&#39;, &#39;audience&#39; (override with `.groups` argument) ggplot(data = powercc.long.summary, mapping = aes(x = audience, y = wtp, fill = power)) + facet_wrap(~ consumption_type) + # create a panel for each consumption type geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) Agora podemos testar formalmente a interação de três vias: # Especifique os dados, a variavel dependente, o identificador (wid), # a variavel que representa a condicao dentro dos sujeitos e as variaveis que representam as condicoes entre os sujeitos. ezANOVA(data = powercc.long, dv = wtp, wid = subject, within = consumption_type, between = power*audience) ## Warning: You have removed one or more Ss from the analysis. Refactoring &quot;subject&quot; for ## ANOVA. ## Warning: Converting &quot;consumption_type&quot; to factor for ANOVA. ## Warning: Data is unbalanced (unequal N per group). Make sure you specified a well- ## considered value for the type argument to ezANOVA(). ## $ANOVA ## Effect DFn DFd F p p&lt;.05 ges ## 2 power 1 139 1.867530e+00 1.739647e-01 9.061619e-03 ## 3 audience 1 139 2.977018e+00 8.667716e-02 1.436772e-02 ## 5 consumption_type 1 139 6.303234e+02 1.687352e-53 * 5.915501e-01 ## 4 power:audience 1 139 5.801046e-03 9.393977e-01 2.840440e-05 ## 6 power:consumption_type 1 139 4.719313e-01 4.932445e-01 1.083172e-03 ## 7 audience:consumption_type 1 139 2.700684e-02 8.697041e-01 6.204919e-05 ## 8 power:audience:consumption_type 1 139 2.982598e+00 8.638552e-02 6.806406e-03 Vemos nesses resultados que a interação de três vias entre poder, público e tipo de consumo é marginalmente significativa. Você pode relatar o seguinte: \"Uma ANOVA de medidas repetidas estabeleceu que a interação de três vias entre poder, público e tipo de consumo era marginalmente significativa (F (1, 139) = 2,98, p = 0,086). "]
]
